# Convex - Other

**Pages:** 57

---

## Uploading and Storing Files

**URL:** https://docs.convex.dev/file-storage/upload-files

**Contents:**
- Uploading and Storing Files
- Uploading files via upload URLs​
  - Calling the upload APIs from a web page​
  - Generating the upload URL​
  - Writing the new storage ID to the database​
  - Limits​
- Uploading files via an HTTP action​
  - Calling the upload HTTP action from a web page​
  - Defining the upload HTTP action​

Upload files to Convex by generated upload urls, or via an custom HTTP Action.

Arbitrarily large files can be uploaded directly to your backend using a generated upload URL. This requires the client to make 3 requests:

In the first mutation that generates the upload URL you can control who can upload files to your Convex storage.

Example: File Storage with Queries and Mutations

Here's an example of uploading an image via a form submission handler to an upload URL generated by a mutation:

An upload URL can be generated by the storage.generateUploadUrl function of the MutationCtx object:

This mutation can control who is allowed to upload files.

The upload URL expires in 1 hour and so should be fetched shortly before the upload is made.

Since the storage ID is returned to the client it is likely you will want to persist it in the database via another mutation:

The file size is not limited, but upload POST request has a 2 minute timeout.

The file upload process can be more tightly controlled by leveraging HTTP actions, performing the whole upload flow using a single request, but requiring correct CORS headers configuration.

The custom upload HTTP action can control who can upload files to your Convex storage. But note that the HTTP action request size is currently limited to 20MB. For larger files you need to use upload URLs as described above.

Example: File Storage with HTTP Actions

Here's an example of uploading an image via a form submission handler to the sendImage HTTP action defined next.

The highlighted lines make the actual request to the HTTP action:

A file sent in the HTTP request body can be stored using the storage.store function of the ActionCtx object. This function returns an Id<"_storage"> of the stored file.

From the HTTP action you can call a mutation to write the storage ID to a document in your database.

To confirm success back to your hosted website, you will need to set the right CORS headers:

You also need to handle the pre-flight OPTIONS request:

**Examples:**

Example 1 (tsx):
```tsx
import { FormEvent, useRef, useState } from "react";import { useMutation } from "convex/react";import { api } from "../convex/_generated/api";export default function App() {  const generateUploadUrl = useMutation(api.messages.generateUploadUrl);  const sendImage = useMutation(api.messages.sendImage);  const imageInput = useRef<HTMLInputElement>(null);  const [selectedImage, setSelectedImage] = useState<File | null>(null);  const [name] = useState(() => "User " + Math.floor(Math.random() * 10000));  async function handleSendImage(event: FormEvent) {    event.preventDefault();    // Step 1: Get 
...
```

Example 2 (ts):
```ts
import { mutation } from "./_generated/server";export const generateUploadUrl = mutation({  handler: async (ctx) => {    return await ctx.storage.generateUploadUrl();  },});
```

Example 3 (ts):
```ts
import { mutation } from "./_generated/server";export const sendImage = mutation({  args: { storageId: v.id("_storage"), author: v.string() },  handler: async (ctx, args) => {    await ctx.db.insert("messages", {      body: args.storageId,      author: args.author,      format: "image",    });  },});
```

Example 4 (tsx):
```tsx
import { FormEvent, useRef, useState } from "react";const convexSiteUrl = import.meta.env.VITE_CONVEX_SITE_URL;export default function App() {  const imageInput = useRef<HTMLInputElement>(null);  const [selectedImage, setSelectedImage] = useState<File | null>(null);  async function handleSendImage(event: FormEvent) {    event.preventDefault();    // e.g. https://happy-animal-123.convex.site/sendImage?author=User+123    const sendImageUrl = new URL(`${convexSiteUrl}/sendImage`);    sendImageUrl.searchParams.set("author", "Jack Smith");    await fetch(sendImageUrl, {      method: "POST",      he
...
```

---

## Data Types

**URL:** https://docs.convex.dev/using/types

**Contents:**
- Data Types
- Convex values​
- System fields​
- Limits​
- Working with undefined​
- Working with dates and times​

All Convex documents are defined as Javascript objects. These objects can have field values of any of the types below.

You can codify the shape of documents within your tables by defining a schema.

Convex supports the following types of values:

Every document in Convex has two automatically-generated system fields:

Convex values must be less than 1MB in total size. This is an approximate limit for now, but if you're running into these limits and would like a more precise method to calculate a document's size, reach out to us. Documents can have nested values, either objects or arrays that contain other Convex types. Convex types can have at most 16 levels of nesting, and the cumulative size of a nested tree of values must be under the 1MB limit.

Table names may contain alphanumeric characters ("a" to "z", "A" to "Z", and "0" to "9") and underscores ("_"), and they cannot start with an underscore.

For information on other limits, see here.

If any of these limits don't work for you, let us know!

The TypeScript value undefined is not a valid Convex value, so it cannot be used in Convex function arguments or return values, or in stored documents.

If you would prefer to avoid the special behaviors of undefined, you can use null instead, which is a valid Convex value.

Convex does not have a special data type for working with dates and times. How you store dates depends on the needs of your application:

For more sophisticated printing (formatting) and manipulation of dates and times use one of the popular JavaScript libraries: date-fns, Day.js, Luxon or Moment.js.

**Examples:**

Example 1 (ts):
```ts
if (args.a === null) {  args.a = undefined;}await ctx.db.patch(id, args);
```

---

## Convex & Auth0

**URL:** https://docs.convex.dev/auth/auth0

**Contents:**
- Convex & Auth0
- Get started​
- Login and logout flows​
- Logged-in and logged-out views​
- User information in React​
- User information in functions​
- Configuring dev and prod tenants​
  - Configuring the backend​
  - Configuring a React client​
- Debugging authentication​

Auth0 is an authentication platform providing login via passwords, social identity providers, one-time email or SMS access codes, multi-factor authentication, and single sign on and basic user management.

Example: Convex Authentication with Auth0

If you're using Next.js see the Next.js setup guide.

This guide assumes you already have a working React app with Convex. If not follow the Convex React Quickstart first. Then:

Follow the Auth0 React Quickstart.

Sign up for a free Auth0 account.

Configure your application, using http://localhost:3000, http://localhost:5173 for Callback and Logout URLs and Allowed Web Origins.

Come back when you finish the Install the Auth0 React SDK step.

In the convex folder create a new file auth.config.ts with the server-side configuration for validating access tokens.

Paste in the domain and clientId values shown in Install the Auth0 React SDK step of the Auth0 quickstart or in your Auth0 application's Settings dashboard.

Run npx convex dev to automatically sync your configuration to your backend.

Now replace your ConvexProvider with an Auth0Provider wrapping ConvexProviderWithAuth0. Add the domain and clientId as props to the Auth0Provider.

Paste in the domain and clientId values shown in Install the Auth0 React SDK step of the Auth0 quickstart or in your Auth0 application's Settings dashboard as props to Auth0Provider.

Now that you have everything set up, you can use the useAuth0() hook to create login and logout buttons for your app.

The login button will redirect the user to the Auth0 universal login page. For details see Add Login to Your Application in the Auth0 React Quickstart.

The logout button will redirect the user to the Auth0 logout endpoint. For details see Add Logout to your Application in the Auth0 React Quickstart.

Use the useConvexAuth() hook instead of the useAuth0 hook when you need to check whether the user is logged in or not. The useConvex hook makes sure that the browser has fetched the auth token needed to make authenticated requests to your Convex backend:

You can also use the Authenticated, Unauthenticated and AuthLoading helper components which use the useConvexAuth hook under the hood:

You can access information about the authenticated user like their name from the useAuth0 hook:

See Auth in Functions to learn about how to access information about the authenticated user in your queries, mutations and actions.

See Storing Users in the Convex Database to learn about how to store u

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { AuthConfig } from "convex/server";export default {  providers: [    {      domain: "your-domain.us.auth0.com",      applicationID: "yourclientid",    },  ]} satisfies AuthConfig;
```

Example 2 (sh):
```sh
npx convex dev
```

Example 3 (tsx):
```tsx
import React from "react";import ReactDOM from "react-dom/client";import App from "./App";import "./index.css";import { ConvexReactClient } from "convex/react";import { ConvexProviderWithAuth0 } from "convex/react-auth0";import { Auth0Provider } from "@auth0/auth0-react";const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);ReactDOM.createRoot(document.getElementById("root")!).render(  <React.StrictMode>    <Auth0Provider      domain="your-domain.us.auth0.com"      clientId="yourclientid"      authorizationParams={{        redirect_uri: window.location.origin,      }}
...
```

Example 4 (tsx):
```tsx
import { useAuth0 } from "@auth0/auth0-react";export default function LoginButton() {  const { loginWithRedirect } = useAuth0();  return <button onClick={loginWithRedirect}>Log in</button>;}
```

---

## Automatic AuthKit Configuration

**URL:** https://docs.convex.dev/auth/authkit/auto-provision

**Contents:**
- Automatic AuthKit Configuration
- Creating WorkOS environments on-demand​
  - Limitations​

AuthKit configuration can be automated for cloud dev deployments: each Convex deployment gets its own WorkOS environment configured and has local environment variables added to .env.local and Convex deployment environment variables set for it.

This integration is in active development and will change as it continues to improve. Today the integration works with the two AuthKit templates offered when running npm create convex@latest.

Automatically provisioning a WorkOS environment for a Convex deployment is enabled by creating a new WorkOS account and team to associate with a Convex team. Once this account has been created, any member of the Convex team can create a WorkOS environment for their development deployments on each of the team's projects.

This happens automatically whenever the WORKOS_CLIENT_ID environment variable is read in the convex/auth.config.ts file but not set on the deployment during a convex dev.

The CLI then makes AuthKit-related configuration changes that replace the manual configuration steps required to configure AuthKit for a development Convex deployment.

Currently this configures the following with the assumed local development domain:

The following local environment variables may be set in .env.local:

WorkOS environments can currently only be created for cloud development deployments. Preview and production deployments must be manually configured.

To manually configure the production deployment, visit the WorkOS page for the production environment for this project and follow these steps. Only one production deployment exists by default per WorkOS team so additional project may need to use separate WorkOS teams.

---

## History

**URL:** https://docs.convex.dev/dashboard/deployments/history

**Contents:**
- History

The history page is only available on Convex Professional.

This history page is an audit log of configuration-related events that have occurred in the selected deployment, such as function deployments, changes to indexes, and changes to environment variables.

You may also view an audit log of team-related events in the team audit log.

---

## CLI

**URL:** https://docs.convex.dev/cli

**Contents:**
- CLI
- Configure​
  - Create a new project​
  - Recreate project configuration​
  - Log out​
- Develop​
  - Run the Convex dev server​
  - Open the dashboard​
  - Open the docs​
  - Run Convex functions​

The Convex command-line interface (CLI) is your interface for managing Convex projects and Convex functions.

To install the CLI, run:

You can view the full list of commands with:

The first time you run

it will ask you to log in your device and create a new Convex project. It will then create:

in a project directory without a set CONVEX_DEPLOYMENT to configure a new or existing project.

Remove the existing Convex credentials from your device, so subsequent commands like npx convex dev can use a different Convex account.

Watches the local filesystem. When you change a function or the schema, the new versions are pushed to your dev deployment and the generated types in convex/_generated are updated. By default, logs from your dev deployment are displayed in the terminal.

It's also possible to run a Convex deployment locally for development.

Open the Convex dashboard.

Get back to these docs!

Run a public or internal Convex query, mutation, or action on your development deployment.

Arguments are specified as a JSON object.

Add --watch to live update the results of a query. Add --push to push local code to the deployment before running the function.

Use --prod to run functions in the production deployment for a project.

You can choose how to pipe logs from your dev deployment to your console:

Use --prod with npx convex logs to tail the prod deployment logs instead.

See description and use-cases: data import.

See description and use-cases: data export.

Display a simple view of the dashboard data page in the command line.

The command supports --limit and --order flags to change data displayed. For more complex filters, use the dashboard data page or write a query.

The npx convex data <table> command works with system tables, such as _storage, in addition to your own tables.

See and update the deployment environment variables which you can otherwise manage on the dashboard environment variables settings page.

The target deployment to push to is determined like this:

Once this command succeeds the new functions will be available immediately.

When run with the CONVEX_DEPLOY_KEY environment variable containing a Preview Deploy Key, this command will:

Create a new Convex deployment. npx convex deploy will infer the Git branch name for Vercel, Netlify, GitHub, and GitLab environments, or the --preview-create option can be used to customize the name associated with the newly created deployment.

Run a command if specified with --cmd. The command

*[Content truncated]*

**Examples:**

Example 1 (sh):
```sh
npm install convex
```

Example 2 (sh):
```sh
npx convex dev
```

Example 3 (sh):
```sh
npx convex dev
```

Example 4 (sh):
```sh
npx convex logout
```

---

## File Storage

**URL:** https://docs.convex.dev/dashboard/deployments/file-storage

**Contents:**
- File Storage

The file storage page displays files stored in your deployment. The page also shows the files' storage IDs, size, and content type. You can upload new files and download or delete existing files.

Storage IDs might be referenced by documents in your database.

When new files are uploaded, the UI will reference the name of the recently uploaded file. However, these names are not persisted and will no longer appear when the page is reloaded.

---

## Data

**URL:** https://docs.convex.dev/dashboard/deployments/data

**Contents:**
- Data
- Filtering documents​
- Writing custom queries​
- Creating tables​
- Creating documents​
- Quick actions (context menu)​
- Editing a cell​
- Editing a document​
- Adding references to other documents​
- Bulk editing documents​

The data page allows you to view and manage all of your tables and documents.

On the left side of the page is a list of your tables. Clicking on a table will allows you to create, view, update, and delete documents in that table.

You may drag-and-drop the column headers in each table to visually re-order the data.

A readonly view of the data page is available in the command line.

You may filters documents on the data page by clicking the "Filter" button on the top of the page.

All fields in a document are filterable by the operations supported in Convex query syntax. Equality and comparisons share the same rules when filtering in the dashboard as a query using the Convex client. You may also filter based on the type of the field.

To add a filter, click the + next to an existing filter. If you add more than one condition, they will be evaluated using the and operation.

For each filter, you must select a field to filter by, operation, and comparison value. In the third input box (selecting a value), you may enter a valid Convex value, such as "a string", 123, or even a complex object, such as { a: { b: 2 } }

When filtering by _creationTime, a date picker will be displayed instead of the normal JavaScript syntax input box. Comparisons for _creationTime are made at the nanosecond granularity, so if you'd like to filter to an exact time, try adding two filter conditions for creationTime >= $time and creationTime <= $time + 1 minute.

You can write a query directly in the dashboard. This allows you to perform arbitrary filtering and transformation of the data, including sorting, joins, grouping and aggregations.

In the ⋮ overflow menu at the top of the data page click on the “Custom query” option.

This opens the same UI used for running your deployed functions, but with the “Custom test query” option selected, which lets you edit the source code for the query. This source code will be sent to your deployment and executed when you click on the “Run Custom Query“ button.

If you're not on the data page, you can still open this UI via the persistent fn button shown on the bottom right of all deployment pages. The keyboard shortcut to open the function runner is Ctrl + ` (backtick).

You may create a table from the dashboard by clicking the "Create Table" button and entering a new name for the table.

You may add individual documents to the table using the “Add Documents” button located in the data table's toolbar.

Once you click “Add Documents” a side pa

*[Content truncated]*

**Examples:**

Example 1 (sh):
```sh
npx convex data [table]
```

---

## Testing

**URL:** https://docs.convex.dev/testing

**Contents:**
- Testing
- Automated tests​
  - convex-test library​
  - Testing against a real backend​
  - Set up testing in CI​
- Manual tests​
  - Running a function in dev​
  - Preview deployments​
  - Staging environment​

Convex makes it easy to test your app via automated tests running in JS or against a real backend, and manually in dev, preview and staging environments.

Use the convex-test library to test your functions in JS via the excellent Vitest testing framework.

Convex open source builds allow you to test all of your backend logic running on a real local Convex backend.

It's a good idea to test your app continuously in a controlled environment. No matter which way automated method you use, it's easy to run them with GitHub Actions.

Manually run a function in dev to quickly see if things are working:

Use preview deployments to get early feedback from your team for your in-progress features.

You can set up a separate project as a staging environment to test against. See Deploying Your App to Production.

---

## Convex Overview

**URL:** https://docs.convex.dev/understanding

**Contents:**
- Convex Overview
- Database​
- Server functions​
- Client libraries​
- Putting it all together​
- Beyond reactivity​
- For human and AI generated code​
- Learn more​

Convex is the open source, reactive database where queries are TypeScript code running right in the database. Just like React components react to state changes, Convex queries react to database changes.

Convex provides a database, a place to write your server functions, and client libraries. It makes it easy to build and scale dynamic live-updating apps.

The following diagram shows the standard three-tier app architecture that Convex enables. We'll start at the bottom and work our way up to the top of this diagram.

The database is at the core of Convex. The Convex database is automatically provisioned when you create your project. There is no connection setup or cluster management.

In Convex, your database queries are just TypeScript code written in your server functions. There is no SQL to write. There are no ORMs needed.

The Convex database is reactive. Whenever any data on which a query depends changes, the query is rerun, and client subscriptions are updated.

Convex is a "document-relational" database. "Document" means you put JSON-like nested objects into your database. "Relational" means you have tables with relations, like tasks assigned to a user using IDs to reference documents in other tables.

The Convex cloud offering runs on top of Amazon RDS using MySQL as its persistence layer. The Open Source version uses SQLite, Postgres and MySQL. The database is ACID-compliant and uses serializable isolation and optimistic concurrency control. All that to say, Convex provides the strictest possible transactional guarantees, and you never see inconsistent data.

When you create a new Convex project, you automatically get a convex/ folder where you write your server functions. This is where all your backend application logic and database query code live.

Example TypeScript server functions that read (query) and write (mutation) to the database.

You read and write to your database through query or mutation functions. Query functions are pure functions that can only read from the database. Mutation functions are transactions that can read or write from the database. These two database functions are not allowed to take any non-deterministic actions like network requests to ensure transactional guarantees.

The entire Convex mutation function is a transaction. There are no begin or end transaction statements to write. Convex automatically retries the function on conflicts, and you don't have to manage anything.

Convex also provides standard general-pu

*[Content truncated]*

**Examples:**

Example 1 (typescript):
```typescript
// A Convex query functionexport const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});// A Convex mutation functionexport const setTaskCompleted = mutation({  args: { taskId: v.id("tasks"), completed: v.boolean() },  handler: async (ctx, { taskId, completed }) => {    // Update the database using TypeScript    await ctx.db.patch(taskId, { completed });  
...
```

Example 2 (tsx):
```tsx
// In your React componentimport { useQuery } from "convex/react";import { api } from "../convex/_generated/api";export function TaskList() {  const data = useQuery(api.tasks.getAllOpenTasks);  return data ?? "Loading...";}
```

Example 3 (typescript):
```typescript
export const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});
```

Example 4 (json):
```json
[  { _id: "e4g", title: "Grocery shopping", complete: false },  { _id: "u9v", title: "Plant new flowers", complete: false },];
```

---

## Agent Mode

**URL:** https://docs.convex.dev/cli/agent-mode

**Contents:**
- Agent Mode

When logged in on your own machine, agents like Cursor and Claude Code can run CLI commands like npx convex env list that use your logged-in credentials run commands against your personal dev environment as if you ran the commands yourself. This works well when you're collaborating with an agent; just like when the agent runs git commit -am "Fix.", the commit will use your local git credentials.

But when cloud-based coding agents like Jules, Devin, Codex, or Cursor background agents run Convex CLI commands, they can't log in. And if you do log in for them, the agent will use your default dev deployment to develop, conflicting with your own changes!

Instead, set CONVEX_AGENT_MODE=anonymous in this environment, causing the agent to use anonymous development to run a separate Convex backend on the VM where the agent is working.

Convex Agent Mode is currently a beta feature. If you have feedback or feature requests, let us know on Discord!

You can set this variable in .env.local or set it in the agent's environment.

In the future CONVEX_AGENT_MODE may support other behaviors like allowing agents to provision their own short-lived cloud deployments.

**Examples:**

Example 1 (text):
```text
CONVEX_AGENT_MODE=anonymous npx convex dev
```

---

## Deleting Files

**URL:** https://docs.convex.dev/file-storage/delete-files

**Contents:**
- Deleting Files

Files stored in Convex can be deleted from mutations, actions, and HTTP actions via the storage.delete() function, which accepts a storage ID.

Storage IDs correspond to documents in the "_storage" system table (see Metadata), so they can be validated using the v.id("_storage").

**Examples:**

Example 1 (ts):
```ts
import { v } from "convex/values";import { Id } from "./_generated/dataModel";import { mutation } from "./_generated/server";export const deleteById = mutation({  args: {    storageId: v.id("_storage"),  },  handler: async (ctx, args) => {    return await ctx.storage.delete(args.storageId);  },});
```

---

## Teams

**URL:** https://docs.convex.dev/dashboard/teams

**Contents:**
- Teams
- General​
- Team Members​
  - Roles and permissions​
    - Team roles​
    - Project Admins​
- Billing​
  - Spending limits​
- Usage​
- Audit Log​

In Convex, your projects are organized by team. Teams are used to share access to your projects with other people. You may switch between teams or create a new team by clicking on the name of your team located on the top of the Convex dashboard. This will open the project selector, where you can switch teams by clicking on the team name once again.

You may change the name of a team or invite new members to a team by clicking on the "Team Settings" button located on the top of the project list page.

The general page allows changing the team name and slug.

You may also delete the team from this page. You can only delete a team after deleting all of it's projects, and removing all other team members from your team. Deleting your team will automatically cancel your Convex subscription.

Use the members settings page to invite or remove members from your team.

Convex has two levels of control for managing access to your team, projects, and deployments. Team-level roles control what a user can do within the team, while project-level permissions control what a user can do within a specific project.

Your team members can have one of the following roles:

The creator of the team is automatically assigned the Admin role. When inviting new team members, you may select a role for them. You may also change the role of a team member at any time.

Admins can do everything developers can, as well as:

In addition to team roles, you may also grant admin access to individual projects by granting team members the "Project Admin" role.

If you are a Project Admin for a given project, you may:

You may assign and remove the Project Admin role for multiple projects at the same time on the member settings page. To assign or remove the Project Admin role for multiple members at the same time, visit the Project Settings page instead.

Use the billing page to upgrade your Convex subscription to a higher tier, or manage your existing subscription.

On paid plans, you can also update your billing contact details, payment method, and view your invoices.

Learn more about Convex pricing.

When you have an active Convex subscription, you can set the spending limits for your team on the billing page:

Spending limits only apply to the resources used by your team’s projects beyond the amounts included in your plan. The seat fees (the amount paid for each developer in your team) are not counted towards the limits. For instance, if you send the spending limit to $0/month, you will be b

*[Content truncated]*

---

## Full Text Search

**URL:** https://docs.convex.dev/text-search

**Contents:**
- Full Text Search
- Defining search indexes​
- Running search queries​
  - Search expressions​
  - Equality expressions​
  - Other filtering​
  - Retrieving results and paginating​
  - Ordering​
- Search Behavior​
  - Typeahead Search​

Full text search allows you to find Convex documents that approximately match a search query.

Unlike normal document queries, search queries look within a string field to find the keywords. Search queries are useful for building features like searching for messages that contain certain words.

Search queries are automatically reactive, consistent, transactional, and work seamlessly with pagination. They even include new documents created with a mutation!

To use full text search you need to:

Search indexes are built and queried using Convex's multi-segment search algorithm on top of Tantivy, a powerful, open-source, full-text search library written in Rust.

Like database indexes, search indexes are a data structure that is built in advance to enable efficient querying. Search indexes are defined as part of your Convex schema.

Every search index definition consists of:

To add a search index onto a table, use the searchIndex method on your table's schema. For example, if you want an index which can search for messages matching a keyword in a channel, your schema could look like:

You can specify search and filter fields on nested documents by using a dot-separated path like properties.name.

A query for "10 messages in channel '#general' that best match the query 'hello hi' in their body" would look like:

This is just a normal database read that begins by querying the search index!

The .withSearchIndex method defines which search index to query and how Convex will use that search index to select documents. The first argument is the name of the index and the second is a search filter expression. A search filter expression is a description of which documents Convex should consider when running the query.

A search filter expression is always a chained list of:

Search expressions are issued against a search index, filtering and ranking documents by their relevance to the search expression's query. Internally, Convex will break up the query into separate words (called terms) and approximately rank documents matching these terms.

In the example above, the expression search("body", "hello hi") would internally be split into "hi" and "hello" and matched against words in your document (ignoring case and punctuation).

The behavior of search incorporates prefix matching rules.

Unlike search expressions, equality expressions will filter to only documents that have an exact match in the given field. In the example above, eq("channel", "#general") will only ma

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";export default defineSchema({  messages: defineTable({    body: v.string(),    channel: v.string(),  }).searchIndex("search_body", {    searchField: "body",    filterFields: ["channel"],    staged: false,  }),});
```

Example 2 (js):
```js
const messages = await ctx.db  .query("messages")  .withSearchIndex("search_body", (q) =>    q.search("body", "hello hi").eq("channel", "#general"),  )  .take(10);
```

Example 3 (js):
```js
const messages = await ctx.db  .query("messages")  .withSearchIndex("search_body", (q) => q.search("body", "hi"))  .filter((q) => q.gt(q.field("_creationTime", Date.now() - 10 * 60000)))  .take(10);
```

---

## Convex Docs

**URL:** https://docs.convex.dev/home

**Contents:**
- Convex Docs
- Tutorial: Build a chat app
- Understanding Convex
- Get Started​
- Prompt to start an app with Convex Chef
- React
- Next.js
- Remix
- TanStack Start
- React Native

Convex is the open source, reactive database where queries are TypeScript code running right in the database. Just like React components react to state changes, Convex queries react to database changes.

Convex provides a database, a place to write your server functions, and client libraries. It makes it easy to build and scale dynamic live-updating apps.

Follow a step-by-step tutorial to build your first Convex app - a real-time chat application.

Learn about the core concepts and architecture that make Convex unique and powerful.

Your favorite frameworks:

Your favorite languages:

Read the team's Perspectives on Stack:

See more walkthroughs and patterns on Stack

---

## Convex & WorkOS AuthKit

**URL:** https://docs.convex.dev/auth/authkit/

**Contents:**
- Convex & WorkOS AuthKit
- Get started​
  - Configuring an existing WorkOS account​
- Client configuration​
  - React​
  - Next.js​
- Next steps​
  - Accessing user information in functions​
  - Accessing user information client-side​
- Configuring dev and prod instances​

WorkOS AuthKit is an authentication solution that enables sign-in using passwords, social login providers, email one-time codes, two-factor authentication, and user management capabilities.

The quickest way to get started is to create an associated WorkOS account through the Convex CLI.

Follow the prompts to create a WorkOS team that will be associated with your Convex team. After this Convex deployments for projects in this team will be able to automatically provision and configure their own WorkOS environments.

That's it! After this you and other members of your Convex team can create and configure development WorkOS environments without visiting workos.com.

To use AuthKit with an existing WorkOS account you'll need to configure the account and copy credentials into the Convex deployment and your local .env.local file.

Sign up for a free WorkOS account at workos.com/sign-up.

In the WorkOS Dashboard, navigate to Authentication and then to AuthKit. From here, click the Set up AuthKit button to enable AuthKit in your account.

Press the Begin setup button with Use AuthKit's customizable hosted UI selected. These options can be filled out however you like until you get to step 4, Add default redirect endpoint URI.

The Redirect URI is the endpoint that WorkOS will return an authorization code to after signing in. This should match your application's domain and port, with /callback as the route. For example, if your application is running at localhost:5173 then the value here should be http://localhost:5173/callback.

Complete the AuthKit setup.

From the get started page under Quick start, find your WORKOS_CLIENT_ID and copy it.

Convex offers a provider that is specifically for integrating with WorkOS AuthKit called <ConvexProviderWithAuthKit>. It works using WorkOS's authkit-react SDK.

Once you've completed the WorkOS setup above, choose your framework below to continue with the integration.

See the following sections for the WorkOS SDK that you're using:

Example: React with Convex and AuthKit

This guide assumes you have AuthKit set up and have a working React app with Convex. If not follow the Convex React Quickstart first. Then:

In your WorkOS Dashboard, click Manage under "Cross-Origin Resource Sharing (CORS)" and add your local development domain (e.g., http://localhost:5173 for Vite) to the list. You'll also need to add your production domain when you deploy. This enables your application to authenticate users through WorkOS AuthKit.

In yo

*[Content truncated]*

**Examples:**

Example 1 (bash):
```bash
npm create convex@latest -- -t react-vite-authkitcd my-app  # or whatever you name the directorynpm run dev
```

Example 2 (env):
```env
# WorkOS AuthKit ConfigurationVITE_WORKOS_CLIENT_ID=your-workos-client-id-hereVITE_WORKOS_REDIRECT_URI=http://localhost:5173/callback
```

Example 3 (ts):
```ts
const clientId = process.env.WORKOS_CLIENT_ID;const authConfig = {  providers: [    {      type: 'customJwt',      issuer: `https://api.workos.com/`,      algorithm: 'RS256',  jwks: `https://api.workos.com/sso/jwks/${clientId}`,  applicationID: clientId,    },    {      type: 'customJwt',      issuer: `https://api.workos.com/user_management/${clientId}`,      algorithm: 'RS256',      jwks: `https://api.workos.com/sso/jwks/${clientId}`,      applicationID: clientId,    },  ],};export default authConfig;
```

Example 4 (sh):
```sh
npx convex dev
```

---

## AI & Search

**URL:** https://docs.convex.dev/search

**Contents:**
- AI & Search

Whether building RAG enabled chatbots or quick search in your applications, Convex provides easy apis to create powerful AI and search enabled products.

Vector Search enables searching for documents based on their semantic meaning. It uses vector embeddings to calculate similarity and retrieve documents that are similar to a given query. Vector search is a key part of common AI techniques like RAG.

Full Text Search enables keyword and phrase search within your documents. It supports prefix matching to enable typeahead search. Convex full text search is also reactive and always up to date like all Convex queries, making it easy to build reliable quick search boxes.

Convex Actions easily enable you to call AI apis, save data to your database, and drive your user interface. See examples of how you can use this to build sophisticated AI applications.

---

## Errors and Warnings

**URL:** https://docs.convex.dev/error/

**Contents:**
- Errors and Warnings
- Write conflict: Optimistic concurrency control​
  - Example A​
  - Example B​
  - Remediation​
  - Resources​

This page explains specific errors thrown by Convex.

See Error Handling to learn about handling errors in general.

This system error is thrown when a mutation repeatedly fails due to conflicting changes from parallel mutation executions.

A mutation updateCounter always updates the same document:

If this mutation is called many times per second, many of its executions will conflict with each other. Convex internally does several retries to mitigate this concern, but if the mutation is called more rapidly than Convex can execute it, some of the invocations will eventually throw this error:

Documents read from or written to the table "counters" changed while this mutation was being run and on every subsequent retry. Another call to this mutation changed the document with ID "123456789101112".

The error message will note the table name, which mutation caused the conflict (in this example its another call to the same mutation), and one document ID which was part of the conflicting change.

Mutation writeCount depends on the entire tasks table:

If the mutation writeCount is called at the same time as many calls to addTask are made, either of the mutations can fail with this error. This is because any change to the "tasks" table will conflict with the writeCount mutation:

Documents read from or written to the table "tasks" changed while this mutation was being run and on every subsequent retry. A call to "addTask" changed the document with ID "123456789101112".

**Examples:**

Example 1 (ts):
```ts
export const updateCounter = mutation({  args: {},  handler: async (ctx) => {    const doc = await ctx.db.get(process.env.COUNTER_ID);    await ctx.db.patch(doc._id, { value: doc.value + 1 });  },});
```

Example 2 (ts):
```ts
export const writeCount = mutation({  args: {    target: v.id("counts"),  },  handler: async (ctx, args) => {    const tasks = await ctx.db.query("tasks").collect();    await ctx.db.patch(args.target, { value: tasks });  },});export const addTask = mutation({  args: {    text: v.string(),  },  handler: async (ctx, args) => {    await ctx.db.insert("tasks", { text: args.text });  },});
```

---

## Scheduling

**URL:** https://docs.convex.dev/scheduling

**Contents:**
- Scheduling
- Durable function components​
  - Workpool
  - Workflow
  - Action Retrier
  - Crons

Convex lets you easily schedule a function to run once or repeatedly in the future. This allows you to build durable workflows like sending a welcome email a day after someone joins or regularly reconciling your accounts with Stripe. Convex provides two different features for scheduling:

Built-in scheduled functions and crons work well for simpler apps and workflows. If you're operating at high scale or need more specific guarantees, use the following higher-level components for durable functions.

Workpool give critical tasks priority by organizing async operations into separate, customizable queues.

Simplify programming long running code flows. Workflows execute durably with configurable retries and delays.

Add reliability to an unreliable external service. Retry idempotent calls a set number of times.

Use cronspec to run functions on a repeated schedule at runtime.

---

## Full Text Search

**URL:** https://docs.convex.dev/search/text-search

**Contents:**
- Full Text Search
- Defining search indexes​
- Running search queries​
  - Search expressions​
  - Equality expressions​
  - Other filtering​
  - Retrieving results and paginating​
  - Ordering​
- Search Behavior​
  - Typeahead Search​

Full text search allows you to find Convex documents that approximately match a search query.

Unlike normal document queries, search queries look within a string field to find the keywords. Search queries are useful for building features like searching for messages that contain certain words.

Search queries are automatically reactive, consistent, transactional, and work seamlessly with pagination. They even include new documents created with a mutation!

To use full text search you need to:

Search indexes are built and queried using Convex's multi-segment search algorithm on top of Tantivy, a powerful, open-source, full-text search library written in Rust.

Like database indexes, search indexes are a data structure that is built in advance to enable efficient querying. Search indexes are defined as part of your Convex schema.

Every search index definition consists of:

To add a search index onto a table, use the searchIndex method on your table's schema. For example, if you want an index which can search for messages matching a keyword in a channel, your schema could look like:

You can specify search and filter fields on nested documents by using a dot-separated path like properties.name.

A query for "10 messages in channel '#general' that best match the query 'hello hi' in their body" would look like:

This is just a normal database read that begins by querying the search index!

The .withSearchIndex method defines which search index to query and how Convex will use that search index to select documents. The first argument is the name of the index and the second is a search filter expression. A search filter expression is a description of which documents Convex should consider when running the query.

A search filter expression is always a chained list of:

Search expressions are issued against a search index, filtering and ranking documents by their relevance to the search expression's query. Internally, Convex will break up the query into separate words (called terms) and approximately rank documents matching these terms.

In the example above, the expression search("body", "hello hi") would internally be split into "hi" and "hello" and matched against words in your document (ignoring case and punctuation).

The behavior of search incorporates prefix matching rules.

Unlike search expressions, equality expressions will filter to only documents that have an exact match in the given field. In the example above, eq("channel", "#general") will only ma

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";export default defineSchema({  messages: defineTable({    body: v.string(),    channel: v.string(),  }).searchIndex("search_body", {    searchField: "body",    filterFields: ["channel"],    staged: false,  }),});
```

Example 2 (js):
```js
const messages = await ctx.db  .query("messages")  .withSearchIndex("search_body", (q) =>    q.search("body", "hello hi").eq("channel", "#general"),  )  .take(10);
```

Example 3 (js):
```js
const messages = await ctx.db  .query("messages")  .withSearchIndex("search_body", (q) => q.search("body", "hi"))  .filter((q) => q.gt(q.field("_creationTime", Date.now() - 10 * 60000)))  .take(10);
```

---

## Testing Local Backend

**URL:** https://docs.convex.dev/testing/convex-backend

**Contents:**
- Testing Local Backend
- Getting Started​
- Limitations​
- CI​

Alternatively to convex-test you can test your functions using the open-source version of the Convex backend.

Follow this guide for the instructions.

Compared to convex-test, which uses a JS mock of the backend, running your tests against the real backend has these advantages:

Note that testing against the local backend also has some drawbacks:

To test your functions in JS with a mocked Convex backend, check out convex-test.

See Continuous Integration to run your tests on a shared remote machine.

---

## Deploy keys

**URL:** https://docs.convex.dev/cli/deploy-key-types

**Contents:**
- Deploy keys
  - Developing locally does not require a deploy key​
  - How to set a deploy key​
- Common uses of deploy keys
  - Deploying from build pipelines​
  - Deploying to preview deployments​
  - Admin keys​
- Rarer types of deploy keys​
  - Project tokens​
  - Development deploy keys​

When you can't log in or use the CLI interactively to specify a project or deployment, for example in a production build environment, the environment variable CONVEX_DEPLOY_KEY can be set to a deploy key to make convex CLI commands run non-interactively.

Deploy keys identify a deployment, project, or team; confer permission to take certain actions with those resources; and can change the behavior of the convex CLI.

Running npx convex dev on a new machine offers the choice to log in or run Convex locally without an account.

Logging in stores a user token at ~/.convex/config.json which is used automatically for all CLI use going forward on that machine. This token grants permission to push code to and read/write data from any deployment this user has access to.

Using Convex locally without logging in (anonymous development) creates a deployment locally and records this preference for this project in the .env.local file in the project directory. The admin key for this anonymous backend is stored in ~/.convex/anonymous-convex-backend-state/ along with its serialized data.

In either of these cases, there's no reason to set CONVEX_DEPLOY_KEY.

Generally deploys keys are set in a dashboard of the service that needs the key but in most shells you can set it right before the command, like

or export it before you run the command

or add it to your .env.local file where it will be found by npx convex when run in that directory.

A production deploy key specifies the production deployment of a project and grants permissions to deploy code to it.

prod:qualified-jaguar-123|eyJ2...0=

You can deploying code from a build pipeline where you can't log in (e.g. Vercel, Netlify, Cloudflare build pipelines)

Read more about deploying to production.

A preview deploy key looks like this:

preview:team-slug:project-slug|eyJ2...0=

Use a preview deploy key to change the behavior of a normal npx convex deploy command to deploy to a preview branch.

Read more about preview deployments.

An admin key provides complete control over a deployment.

An admin key might look like

bold-hyena-681|01c2...c09c

Unlike other types of deploy key, an admin key does not require a network connection to https://convex.dev to be used since it's a irrevocable secret baked into the deployment when created.

These keys are used to control anonymous Convex deployments locally without logging in, but rarely need to be set explicitly.

Setting CONVEX_DEPLOY_KEY to one will cause the Convex CLI to 

*[Content truncated]*

**Examples:**

Example 1 (text):
```text
CONVEX_DEPLOY_KEY='key goes here' npx convex dev
```

Example 2 (text):
```text
export CONVEX_DEPLOY_KEY='key goes here'npx convex dev
```

---

## Debugging Authentication

**URL:** https://docs.convex.dev/auth/debug

**Contents:**
- Debugging Authentication
- Frequently encountered issues​
  - ctx.auth.getUserIdentity() returns null in a query​
- Step 1: Check whether authentication works on the backend​
- Step 2: Check whether authentication works on the frontend​
- Step 3: Check that backend configuration matches frontend configuration​

You have followed one of our authentication guides but something is not working. You have double checked that you followed all the steps, and that you used the correct secrets, but you are still stuck.

This often happens when subscribing to queries via useQuery in React, without waiting for the client to be authenticated. Even if the user has been logged-in previously, it takes some time for the client to authenticate with the Convex backend. Therefore on page load, ctx.auth.getUserIdentity() called within a query returns null.

To handle this, you can either:

If you are using fetchQuery for Next.js Server Rendering, make sure you are explicitly passing in a JWT token as documented here.

If this hasn't helped, follow the steps below to resolve your issue.

Then call this function from whichever client you're using to talk to Convex.

Open the logs page on your dashboard.

What do you see on the logs page?

Answer: I don't see anything:

When you resolved the cause you should see the log appear.

Answer: I see a log with 'server identity' null:

Answer: I see a log with 'server identity' { tokenIdentifier: '... }

Great, you are all set!

No matter which client you use, it must pass a JWT token to your backend for authentication to work.

The most bullet-proof way of ensuring your client is passing the token to the backend, is to inspect the traffic between them.

If you're using a client from the web browser, open the Network tab in your browser's developer tools.

For Websocket-based clients (ConvexReactClient and ConvexClient), filter for the sync name and select WS as the type of traffic. Check the sync items. After the client is initialized (commonly after loading the page), it will send a message (check the Messages tab) with type: "Authenticate", and value will be the authentication token.

For HTTP based clients (ConvexHTTPClient and the HTTP API), select Fetch/XHR as the type of traffic. You should see an individual network request for each function call, with an Authorization header with value Bearer followed by the authentication token.

Do you see the authentication token in the traffic?

Potential cause: The Convex client is not configured to get/fetch a JWT token. You're not using ConvexProviderWithClerk/ConvexProviderWithAuth0/ConvexProviderWithAuth with the ConvexReactClient or you forgot to call setAuth on ConvexHTTPClient or ConvexClient.

Potential cause: You are not signed in, so the token is null or undefined and the ConvexReactClien

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
console.log("server identity", await ctx.auth.getUserIdentity());
```

Example 2 (tsx):
```tsx
// import { useAuth } from "@clerk/nextjs"; // for Next.jsimport { useAuth } from "@clerk/clerk-react";const { getToken } = useAuth();console.log(getToken({ template: "convex" }));
```

Example 3 (tsx):
```tsx
import { useAuth0 } from "@auth0/auth0-react";const { getAccessTokenSilently } = useAuth0();const response = await getAccessTokenSilently({  detailedResponse: true,});const token = response.id_token;console.log(token);
```

---

## Settings

**URL:** https://docs.convex.dev/dashboard/deployments/deployment-settings

**Contents:**
- Settings
- URL and Deploy Key​
- Environment Variables​
- Authentication​
- Backup & Restore​
- Integrations​
- Pause Deployment​

The deployment settings page gives you access to information and configuration options related to a specific deployment (production, your personal development deployment, or a preview deployment).

The URL and deploy key page shows:

The environment variables page lets you add, change, remove and copy the deployment's environment variables.

The authentication page shows the values configured in your auth.config.js for user authentication implementation.

The backup & restore page lets you backup the data stored in your deployment's database and file storage. On this page, you can schedule periodic backups.

The integrations page allows you to configure log streaming, exception reporting, and streaming export integrations.

On the pause deployment page you can pause your deployment with the pause button.

---

## Components

**URL:** https://docs.convex.dev/components

**Contents:**
- Components
- Full Components Directory
- Durable Functions​
- Workflow
- Workpool
- Crons
- Action Retrier
- Database​
- Sharded Counter
- Migrations

Convex Components package up code and data in a sandbox that allows you to confidently and quickly add new features to your backend.

Convex Components are like mini self-contained Convex backends, and installing them is always safe. They can't read your app's tables or call your app's functions unless you pass them in explicitly.

You can read about the full vision in Convex: The Software-Defined Database

The Convex team has built a few components that add new features to your backend. You'll eventually be able to author your own components to use within your project and to share with the community, but we haven't stabilized and documented the authoring APIs yet.

Each component is installed as its own independent library from NPM. Check out the component's README for installation and usage instructions. You can see the full directory on the Convex website.

Async code flow as durable functions.

Async durable function queue.

Dynamic runtime cron management

Retry failed external calls automatically

High-throughput counter operations

Define and run migrations

Efficient sums and counts

Store and search locations

Store and serve files

Real-time collaborative text editing

Send mobile push notifications

Send and receive SMS messages

Sync feature flags with backend

Add subscriptions and billing

Define agents with tools and memory

Stream and store text data

Control resource usage rates

Cache expensive external calls

The underlying authoring APIs for components are still in flux. The Convex team authored components listed below will be kept up to date as the APIs change.

Components can be thought of as a combination of concepts from frontend components, third party APIs, and both monolith and service-oriented architectures.

Similar to frontend components, Convex Components encapsulate state and behavior and allow exposing a clean interface. However, instead of just storing state in memory, these can have internal state machines that can persist between user sessions, span users, and change in response to external inputs, such as webhooks. Components can store data in a few ways:

Typically, libraries require configuring a third party service to add stateful off-the-shelf functionality, which lack the transactional guarantees that come from storing state in the same database.

Similar to regular npm libraries, Convex Components include functions, type safety, and are called from your code. However, they also provide extra guarantees.

Being abl

*[Content truncated]*

---

## Storing Generated Files

**URL:** https://docs.convex.dev/file-storage/store-files

**Contents:**
- Storing Generated Files
- Storing files in actions​

Files can be uploaded to Convex from a client and stored directly, see Upload.

Alternatively files can also be stored after they've been fetched or generated in actions and HTTP actions. For example you might call a third-party API to generate an image based on a user prompt and then store that image in Convex.

Example: Dall-E Storage & Action

Storing files in actions is similar to uploading a file via an HTTP action.

The action takes these steps:

Storage IDs correspond to documents in the "_storage" system table (see Metadata), so they can be validated using the v.id("_storage") validator and typed as Id<"_storage"> in TypeScript.

**Examples:**

Example 1 (ts):
```ts
import { action, internalMutation, query } from "./_generated/server";import { internal } from "./_generated/api";import { v } from "convex/values";import { Id } from "./_generated/dataModel";export const generateAndStore = action({  args: { prompt: v.string() },  handler: async (ctx, args) => {    // Not shown: generate imageUrl from `prompt`    const imageUrl = "https://....";    // Download the image    const response = await fetch(imageUrl);    const image = await response.blob();    // Store the image in Convex    const storageId: Id<"_storage"> = await ctx.storage.store(image);    // Wri
...
```

---

## Optimistic Updates

**URL:** https://docs.convex.dev/using/optimistic-updates

**Contents:**
- Optimistic Updates
- Simple example​
- Complex example​
- Learning more​

Even though Convex queries are completely reactive, sometimes you'll want to update your UI before the mutation changes propagate back to the client. To accomplish this, you can configure an optimistic update to execute as part of your mutation.

Optimistic updates are temporary, local changes to your query results which are used to make your app more responsive. These updates are made by functions registered on a mutation invocation with the .withOptimisticUpdate configuration option.

Optimistic updates are run when a mutation is initiated, rerun if the local query results change, and rolled back when a mutation completes.

Here is how an optimistic update could be added to an increment mutation in a simple counter app:

Optimistic updates receive a localStore, a view of the Convex client's internal state, followed by the arguments to the mutation.

This optimistic update updates the api.counter.get query to be increment higher if it's loaded.

If we want to add an optimistic update to a multi-channel chat app, that might look like:

This optimistic update changes the api.messages.list query for the current channel to include a new message. The newly created message object should match the structure of the real messages generated by the api.messages.list query on the server.

Because this message includes the client's current time (not the server's), it will inevitably not match the api.messages.list query after the mutation runs. That's okay! The Convex client will handle rolling back this update after the mutation completes and the queries are updated. If there are small mistakes in optimistic updates, the UI will always eventually render the correct values.

Similarly, the update creates a temporary Id with new Id("messages", crypto.randomUUID()). This will also be rolled back and replaced with the true ID once the server assigns it.

Lastly, note that this update creates a new array of messages instead of using existingMessages.push(newMessage). This is important! Mutating objects inside of optimistic updates will corrupt the client's internal state and lead to surprising results. Always create new objects inside of optimistic updates.

To learn more, check out our API documentation:

If you'd like some hands on experience, try adding optimistic updates to the tutorial app! If you do, you should notice the app feels snappier — just a little, Convex is pretty fast already! — but otherwise works the same.

To explore even further, try inserting a mista

*[Content truncated]*

**Examples:**

Example 1 (tsx):
```tsx
import { api } from "../convex/_generated/api";import { useMutation } from "convex/react";export function IncrementCounter() {  const increment = useMutation(api.counter.increment).withOptimisticUpdate(    (localStore, args) => {      const { increment } = args;      const currentValue = localStore.getQuery(api.counter.get);      if (currentValue !== undefined) {        localStore.setQuery(api.counter.get, {}, currentValue + increment);      }    },  );  const incrementCounter = () => {    increment({ increment: 1 });  };  return <button onClick={incrementCounter}>+1</button>;}
```

Example 2 (tsx):
```tsx
import { api } from "../convex/_generated/api";import { useMutation } from "convex/react";import { Id } from "../convex/_generated/dataModel";export function MessageSender(props: { channel: Id<"channels"> }) {  const sendMessage = useMutation(api.messages.send).withOptimisticUpdate(    (localStore, args) => {      const { channel, body } = args;      const existingMessages = localStore.getQuery(api.messages.list, {        channel,      });      // If we've loaded the api.messages.list query, push an optimistic message      // onto the list.      if (existingMessages !== undefined) {        con
...
```

---

## Data

**URL:** https://docs.convex.dev/dashboard/deployments/data/

**Contents:**
- Data
- Filtering documents​
- Writing custom queries​
- Creating tables​
- Creating documents​
- Quick actions (context menu)​
- Editing a cell​
- Editing a document​
- Adding references to other documents​
- Bulk editing documents​

The data page allows you to view and manage all of your tables and documents.

On the left side of the page is a list of your tables. Clicking on a table will allows you to create, view, update, and delete documents in that table.

You may drag-and-drop the column headers in each table to visually re-order the data.

A readonly view of the data page is available in the command line.

You may filters documents on the data page by clicking the "Filter" button on the top of the page.

All fields in a document are filterable by the operations supported in Convex query syntax. Equality and comparisons share the same rules when filtering in the dashboard as a query using the Convex client. You may also filter based on the type of the field.

To add a filter, click the + next to an existing filter. If you add more than one condition, they will be evaluated using the and operation.

For each filter, you must select a field to filter by, operation, and comparison value. In the third input box (selecting a value), you may enter a valid Convex value, such as "a string", 123, or even a complex object, such as { a: { b: 2 } }

When filtering by _creationTime, a date picker will be displayed instead of the normal JavaScript syntax input box. Comparisons for _creationTime are made at the nanosecond granularity, so if you'd like to filter to an exact time, try adding two filter conditions for creationTime >= $time and creationTime <= $time + 1 minute.

You can write a query directly in the dashboard. This allows you to perform arbitrary filtering and transformation of the data, including sorting, joins, grouping and aggregations.

In the ⋮ overflow menu at the top of the data page click on the “Custom query” option.

This opens the same UI used for running your deployed functions, but with the “Custom test query” option selected, which lets you edit the source code for the query. This source code will be sent to your deployment and executed when you click on the “Run Custom Query“ button.

If you're not on the data page, you can still open this UI via the persistent fn button shown on the bottom right of all deployment pages. The keyboard shortcut to open the function runner is Ctrl + ` (backtick).

You may create a table from the dashboard by clicking the "Create Table" button and entering a new name for the table.

You may add individual documents to the table using the “Add Documents” button located in the data table's toolbar.

Once you click “Add Documents” a side pa

*[Content truncated]*

**Examples:**

Example 1 (sh):
```sh
npx convex data [table]
```

---

## TypeScript

**URL:** https://docs.convex.dev/understanding/best-practices/typescript

**Contents:**
- TypeScript
- Writing Convex functions in TypeScript​
- Adding a schema​
- Type annotating server-side helpers​
  - Inferring types from validators​
  - Document types without system fields​
- Writing frontend code in TypeScript​
  - Type annotating client-side code​
    - Using inferred function return types​
- Turning strings into valid document IDs​

Convex provides end-to-end type support when Convex functions are written in TypeScript.

You can gradually add TypeScript to a Convex project: the following steps provide progressively better type support. For the best support you'll want to complete them all.

Example: TypeScript and Schema

The first step to improving type support in a Convex project is to writing your Convex functions in TypeScript by using the .ts extension.

If you are using argument validation, Convex will infer the types of your functions arguments automatically:

Otherwise you can annotate the arguments type manually:

This can be useful for internal functions accepting complicated types.

If TypeScript is installed in your project npx convex dev and npx convex deploy will typecheck Convex functions before sending code to the Convex backend.

Convex functions are typechecked with the tsconfig.json in the Convex folder: you can modify some parts of this file to change typechecking settings, or delete this file to disable this typecheck.

You'll find most database methods have a return type of Promise<any> until you add a schema.

Once you define a schema the type signature of database methods will be known. You'll also be able to use types imported from convex/_generated/dataModel in both Convex functions and clients written in TypeScript (React, React Native, Node.js etc.).

The types of documents in tables can be described using the Doc type from the generated data model and references to documents can be described with parametrized Document IDs.

When you want to reuse logic across Convex functions you'll want to define helper TypeScript functions, and these might need some of the provided context, to access the database, authentication and any other Convex feature.

Convex generates types corresponding to documents and IDs in your database, Doc and Id, as well as QueryCtx, MutationCtx and ActionCtx types based on your schema and declared Convex functions:

Validators can be reused between argument validation and schema validation. You can use the provided Infer type to get a TypeScript type corresponding to a validator:

All documents in Convex include the built-in _id and _creationTime fields, and so does the generated Doc type. When creating or updating a document you might want use the type without the system fields. Convex provides WithoutSystemFields for this purpose:

All Convex JavaScript clients, including React hooks like useQuery and useMutation provide end to end typ

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { mutation } from "./_generated/server";import { v } from "convex/values";export default mutation({  args: {    body: v.string(),    author: v.string(),  },  // Convex knows that the argument type is `{body: string, author: string}`.  handler: async (ctx, args) => {    const { body, author } = args;    await ctx.db.insert("messages", { body, author });  },});
```

Example 2 (ts):
```ts
import { internalMutation } from "./_generated/server";export default internalMutation({  // To convert this function from JavaScript to  // TypeScript you annotate the type of the arguments object.  handler: async (ctx, args: { body: string; author: string }) => {    const { body, author } = args;    await ctx.db.insert("messages", { body, author });  },});
```

Example 3 (ts):
```ts
import { query } from "./_generated/server";export const list = query({  args: {},  // The inferred return type of `handler` is now `Promise<Doc<"messages">[]>`  handler: (ctx) => {    return ctx.db.query("messages").collect();  },});
```

Example 4 (ts):
```ts
// Types based on your schemaimport { Doc, Id } from "./_generated/dataModel";// Types based on your schema and declared functionsimport {  QueryCtx,  MutationCtx,  ActionCtx,  DatabaseReader,  DatabaseWriter,} from "./_generated/server";// Types that don't depend on schema or functionimport {  Auth,  StorageReader,  StorageWriter,  StorageActionWriter,} from "convex/server";// Note that a `MutationCtx` also satisfies the `QueryCtx` interfaceexport function myReadHelper(ctx: QueryCtx, id: Id<"channels">) {  /* ... */}export function myActionHelper(ctx: ActionCtx, doc: Doc<"messages">) {  /* ..
...
```

---

## Custom OIDC Provider

**URL:** https://docs.convex.dev/auth/advanced/custom-auth

**Contents:**
- Custom OIDC Provider
- Server-side integration​
- Client-side integration​
  - Integrating a new identity provider​
  - Using the new provider​
  - Debugging​

Note: This is an advanced feature! We recommend sticking with the supported third-party authentication providers.

Convex can be integrated with any identity provider supporting the OpenID Connect protocol. At minimum this means that the provider can issue ID tokens and exposes the corresponding JWKS. The ID token is passed from the client to your Convex backend which ensures that the token is valid and enables you to query the user information embedded in the token, as described in Auth in Functions.

Just like with Clerk and Auth0, the backend needs to be aware of the domain of the Issuer and your application's specific applicationID for a given identity provider.

Add these to your convex/auth.config.ts file:

The applicationID property must exactly match the aud field of your JWT and the domain property must exactly match the iss field of the JWT. Use a tool like jwt.io to view an JWT and confirm these fields match exactly.

If multiple providers are provided, the first one fulfilling the above criteria will be used.

If you're not able to obtain tokens with an aud field, you'll need to instead configure a Custom JWT. If you're not sure if your token is an OIDC ID token, check the spec for a list of all required fields.

OIDC requires the routes ${domain}/.well-known/jwks.json and ${domain}/.well-known/openid-configuration. domain may include a path like https://your.issuer.url.com/api/auth. This isn't common for third party auth providers but may be useful if you're implementing OIDC on your own server.

The ConvexProviderWithAuth component provides a convenient abstraction for building an auth integration similar to the ones Convex provides for Clerk and Auth0.

In the following example we build an integration with an imaginary "ProviderX", whose React integration includes AuthProviderXReactProvider and useProviderXAuth hook.

First we replace ConvexProvider with AuthProviderXReactProvider wrapping ConvexProviderWithAuth at the root of our app:

All we really need is to implement the useAuthFromProviderX hook which gets passed to the ConvexProviderWithAuth component.

This useAuthFromProviderX hook provides a translation between the auth provider API and the ConvexReactClient API, which is ultimately responsible for making sure that the ID token is passed down to your Convex backend.

If you successfully follow the steps above you can now use the standard Convex utilities for checking the authentication state: the useConvexAuth() hook and the Authent

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { AuthConfig } from "convex/server";export default {  providers: [    {      domain: "https://your.issuer.url.com",      applicationID: "your-application-id",    },  ],} satisfies AuthConfig;
```

Example 2 (jsx):
```jsx
import { AuthProviderXReactProvider } from "providerX";import { ConvexProviderWithAuth } from "convex/react";root.render(  <StrictMode>    <AuthProviderXReactProvider>      <ConvexProviderWithAuth client={convex} useAuth={useAuthFromProviderX}>        <App />      </ConvexProviderWithAuth>    </AuthProviderXReactProvider>  </StrictMode>,);
```

Example 3 (jsx):
```jsx
function useAuthFromProviderX() {  const { isLoading, isAuthenticated, getToken } = useProviderXAuth();  const fetchAccessToken = useCallback(    async ({ forceRefreshToken }) => {      // Here you can do whatever transformation to get the ID Token      // or null      // Make sure to fetch a new token when `forceRefreshToken` is true      return await getToken({ ignoreCache: forceRefreshToken });    },    // If `getToken` isn't correctly memoized    // remove it from this dependency array    [getToken],  );  return useMemo(    () => ({      // Whether the auth provider is in a loading state  
...
```

---

## Projects

**URL:** https://docs.convex.dev/dashboard/projects

**Contents:**
- Projects
- Creating a project​
- Project Settings​
- Deleting projects​

A project corresponds to a codebase that uses Convex, which contains a production deployment and one personal deployment for each team member.

Clicking on a project in the landing page will redirect you to project details.

Projects can be created from the dashboard or from the CLI. To create a project from the dashboard click on the Create Project button.

You can access project-level settings by clicking on the triple-dot ⋮ button on each Project card on the Projects page.

On the Project Settings page, you can:

To delete a project, click on the triple-dot ⋮ button on the Project card and select "Delete". You may also delete your project from the Project Settings page.

Once a project is deleted, it cannot be recovered. All deployments and data associated with the project will be permanently removed. When deleting a project from the dashboard, you will be asked to confirm the deletion. Projects with activity in the production deployment will have additional confirmation steps to prevent accidental deletion.

---

## Accessing File Metadata

**URL:** https://docs.convex.dev/file-storage/file-metadata

**Contents:**
- Accessing File Metadata
- Accessing metadata from actions (deprecated)​

Every stored file is reflected as a document in the "_storage" system table. File metadata of a file can be accessed from queries and mutations via db.system.get and db.system.query:

This is an example of the returned document:

The returned document has the following fields:

You can check the metadata manually on your dashboard.

Alternatively, a storage.getMetadata() function is available to access individual file metadata from actions and HTTP actions:

Note that storage.getMetadata() returns a FileMetadata, which has a slightly different shape than the result from db.system.get.

**Examples:**

Example 1 (ts):
```ts
import { v } from "convex/values";import { query } from "./_generated/server";export const getMetadata = query({  args: {    storageId: v.id("_storage"),  },  handler: async (ctx, args) => {    return await ctx.db.system.get(args.storageId);  },});export const listAllFiles = query({  handler: async (ctx) => {    // You can use .paginate() as well    return await ctx.db.system.query("_storage").collect();  },});
```

Example 2 (json):
```json
{  "_creationTime": 1700697415295.742,  "_id": "3k7ty84apk2zy00ay4st1n5p9kh7tf8",  "contentType": "image/jpeg",  "sha256": "cb58f529b2ed5a1b8b6681d91126265e919ac61fff6a367b8341c0f46b06a5bd",  "size": 125338}
```

Example 3 (ts):
```ts
import { v } from "convex/values";import { action } from "./_generated/server";export const getMetadata = action({  args: { storageId: v.id("_storage") },  handler: async (ctx, args) => {    return await ctx.storage.getMetadata(args.storageId);  },});
```

---

## Convex & Clerk

**URL:** https://docs.convex.dev/auth/clerk

**Contents:**
- Convex & Clerk
- Get started​
  - React​
  - Next.js​
  - Tanstack Start​
- Next steps​
  - Accessing user information in functions​
  - Accessing user information client-side​
- Configuring dev and prod instances​
  - Configuring the backend​

Clerk is an authentication platform providing login via passwords, social identity providers, one-time email or SMS access codes, and multi-factor authentication and user management.

Convex offers a provider that is specifically for integrating with Clerk called <ConvexProviderWithClerk>. It works with any of Clerk's React-based SDKs, such as the Next.js and Expo SDKs.

See the following sections for the Clerk SDK that you're using:

Example: React with Convex and Clerk

This guide assumes you already have a working React app with Convex. If not follow the Convex React Quickstart first. Then:

Sign up for a free Clerk account at clerk.com/sign-up.

Choose how you want your users to sign in.

In the Clerk Dashboard, navigate to the JWT templates page.

Select New template and then from the list of templates, select Convex. You'll be redirected to the template's settings page. Do NOT rename the JWT token. It must be called convex.

Copy and save the Issuer URL somewhere secure. This URL is the issuer domain for Clerk's JWT templates, which is your Clerk app's Frontend API URL. In development, it's format will be https://verb-noun-00.clerk.accounts.dev. In production, it's format will be https://clerk.<your-domain>.com.

In your app's convex folder, create a new file auth.config.ts with the following code. This is the server-side configuration for validating access tokens.

Run npx convex dev to automatically sync your configuration to your backend.

In a new terminal window, install the Clerk React SDK:

In the Clerk Dashboard, navigate to the API keys page. In the Quick Copy section, copy your Clerk Publishable Key and set it as the CLERK_PUBLISHABLE_KEY environment variable. If you're using Vite, you will need to prefix it with VITE_.

Both Clerk and Convex have provider components that are required to provide authentication and client context.

You should already have <ConvexProvider> wrapping your app. Replace it with <ConvexProviderWithClerk>, and pass Clerk's useAuth() hook to it.

Then, wrap it with <ClerkProvider>. <ClerkProvider> requires a publishableKey prop, which you can set to the VITE_CLERK_PUBLISHABLE_KEY environment variable.

You can control which UI is shown when the user is signed in or signed out using Convex's <Authenticated>, <Unauthenticated> and <AuthLoading> helper components. These should be used instead of Clerk's <SignedIn>, <SignedOut> and <ClerkLoading> components, respectively.

It's important to use the useConvexAuth() hook 

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { AuthConfig } from "convex/server";export default {  providers: [    {      // Replace with your own Clerk Issuer URL from your "convex" JWT template      // or with `process.env.CLERK_JWT_ISSUER_DOMAIN`      // and configure CLERK_JWT_ISSUER_DOMAIN on the Convex Dashboard      // See https://docs.convex.dev/auth/clerk#configuring-dev-and-prod-instances      domain: process.env.CLERK_JWT_ISSUER_DOMAIN!,      applicationID: "convex",    },  ]} satisfies AuthConfig;
```

Example 2 (sh):
```sh
npx convex dev
```

Example 3 (sh):
```sh
npm install @clerk/clerk-react
```

Example 4 (env):
```env
VITE_CLERK_PUBLISHABLE_KEY=YOUR_PUBLISHABLE_KEY
```

---

## All articles

**URL:** https://stack.convex.dev/articles

---

## Dashboard

**URL:** https://docs.convex.dev/dashboard

**Contents:**
- Dashboard

The dashboard is the central hub for managing your Convex projects. Here you can create and manage your Convex teams, projects, and deployments.

---

## Indexes

**URL:** https://docs.convex.dev/using/indexes

**Contents:**
- Indexes
- Defining indexes​
- Querying documents using indexes​
- Sorting with indexes​
- Staged indexes​
- Limits​

Indexes are a data structure that allow you to speed up your document queries by telling Convex how to organize your documents. Indexes also allow you to change the order of documents in query results.

For a more in-depth introduction to indexing see Indexes and Query Performance.

Indexes are defined as part of your Convex schema. Each index consists of:

To add an index onto a table, use the index method on your table's schema:

The by_channel index is ordered by the channel field defined in the schema. For messages in the same channel, they are ordered by the system-generated _creationTime field which is added to all indexes automatically.

By contrast, the by_channel_user index orders messages in the same channel by the user who sent them, and only then by _creationTime.

Indexes are created in npx convex dev and npx convex deploy.

You may notice that the first deploy that defines an index is a bit slower than normal. This is because Convex needs to backfill your index. The more data in your table, the longer it will take Convex to organize it in index order. If you need to add indexes to large tables, use a staged index.

You can feel free to query an index in the same deploy that defines it. Convex will ensure that the index is backfilled before the new query and mutation functions are registered.

In addition to adding new indexes, npx convex deploy will delete indexes that are no longer present in your schema. Make sure that your indexes are completely unused before removing them from your schema!

A query for "messages in channel created 1-2 minutes ago" over the by_channel index would look like:

The .withIndex method defines which index to query and how Convex will use that index to select documents. The first argument is the name of the index and the second is an index range expression. An index range expression is a description of which documents Convex should consider when running the query.

The choice of index both affects how you write the index range expression and what order the results are returned in. For instance, by making both a by_channel and by_channel_user index, we can get results within a channel ordered by _creationTime or by user, respectively. If you were to use the by_channel_user index like this:

The results would be all of the messages in a channel ordered by user, then by _creationTime. If you were to use by_channel_user like this:

The results would be the messages in the given channel sent by user, ordered by _creat

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";// Define a messages table with two indexes.export default defineSchema({  messages: defineTable({    channel: v.id("channels"),    body: v.string(),    user: v.id("users"),  })    .index("by_channel", ["channel"])    .index("by_channel_user", ["channel", "user"]),});
```

Example 2 (ts):
```ts
const messages = await ctx.db  .query("messages")  .withIndex("by_channel", (q) =>    q      .eq("channel", channel)      .gt("_creationTime", Date.now() - 2 * 60000)      .lt("_creationTime", Date.now() - 60000),  )  .collect();
```

Example 3 (ts):
```ts
const messages = await ctx.db  .query("messages")  .withIndex("by_channel_user", (q) => q.eq("channel", channel))  .collect();
```

Example 4 (ts):
```ts
const messages = await ctx.db  .query("messages")  .withIndex("by_channel_user", (q) =>    q.eq("channel", channel).eq("user", user),  )  .collect();
```

---

## 

**URL:** https://docs.convex.dev/

---

## Logs

**URL:** https://docs.convex.dev/dashboard/deployments/logs

**Contents:**
- Logs
  - Filter logs​
  - Log Types​

The logs page is a realtime view of all activity that occurs within your deployment.

The logs page provides a short history of recent function logs, and will display new logs as they are generated. To store a longer history of logs, you may configure a log stream.

Function activity includes:

In addition to function activity, deployment events describing configuration changes will be present here.

Clicking on log will open a view for all logs associated with the same Request ID as the selected log. This can be useful for debugging errors and understanding the context of a function execution.

You can use controls on the top of this page to filter logs by text, function name, execution status, and log severity.

Use the "Filter logs..." text box on the top of the page to filter log text.

You can use the “Functions” drop-down list to include or exclude functions from the results.

You can also find logs for a particular error using "Filter logs" and the Convex request id. For example if you see this Error in your browser console:

You can view the logs for that function in your dashboard by pasting that Request ID into the 'Search logs...' search bar on the Logs page of your Convex dashboard. Note that because this page is not a complete historical view of logs, you may not find logs for older requests.

Most error reporting services and log sinks should also be searchable by Request ID.

Logs can also be filtered by type. Types include function outcomes (success or failure) and severity levels (info, warn, debug, error).

All failed executions will include a reason, which will usually be a JavaScript exception.

---

## Schedules

**URL:** https://docs.convex.dev/dashboard/deployments/schedules

**Contents:**
- Schedules
- Scheduled functions UI​
- Cron jobs UI​

The schedules page displays all scheduled functions and cron jobs in your deployment. Use the tabs at the top of this page to switch between scheduled functions and cron jobs.

The scheduled functions UI shows a list of all upcoming function invocation. From here, you can filter to scheduled runs for a specific function, and cancel scheduled functions runs.

The cron jobs UI lists all of your cron jobs, including their run frequency and scheduled run time.

Expanding a specific cron job will open the execution history for the selected job.

---

## Vector Search

**URL:** https://docs.convex.dev/search/vector-search

**Contents:**
- Vector Search
- Defining vector indexes​
- Running vector searches​
  - Filter expressions​
  - Other filtering​
  - Ordering​
- Advanced patterns​
  - Using a separate table to store vectors​
  - Fetching results and adding new documents​
- Limits​

Vector search allows you to find Convex documents similar to a provided vector. Typically, vectors will be embeddings which are numerical representations of text, images, or audio.

Embeddings and vector search enable you to provide useful context to LLMs for AI powered applications, recommendations for similar content and more.

Vector search is consistent and fully up-to-date. You can write a vector and immediately read it from a vector search. Unlike full text search, however, vector search is only available in Convex actions.

Example: Vector Search App

To use vector search you need to:

Like database indexes, vector indexes are a data structure that is built in advance to enable efficient querying. Vector indexes are defined as part of your Convex schema.

To add a vector index onto a table, use the vectorIndex method on your table's schema. Every vector index has a unique name and a definition with:

For example, if you want an index that can search for similar foods within a given cuisine, your table definition could look like:

You can specify vector and filter fields on nested documents by using a dot-separated path like properties.name.

Unlike database queries or full text search, vector searches can only be performed in a Convex action.

They generally involve three steps:

Here's an example of the first two steps for searching for similar French foods based on a description:

An example of the first step can be found here in the vector search demo app.

Focusing on the second step, the vectorSearch API takes in the table name, the index name, and finally a VectorSearchQuery object describing the search. This object has the following fields:

It returns an Array of objects containing exactly two fields:

Neither the underlying document nor the vector are included in results, so once you have the list of results, you will want to load the desired information about the results.

There are a few strategies for loading this information documented in the Advanced Patterns section.

For now, let's load the documents and return them from the action. To do so, we'll pass the list of results to a Convex query and run it inside of our action, returning the result:

As mentioned above, vector searches support efficiently filtering results by additional fields on your document using either exact equality on a single field, or an OR of expressions.

For example, here's a filter for foods with cuisine exactly equal to "French":

You can also filter document

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
foods: defineTable({  description: v.string(),  cuisine: v.string(),  embedding: v.array(v.float64()),}).vectorIndex("by_embedding", {  vectorField: "embedding",  dimensions: 1536,  filterFields: ["cuisine"],}),
```

Example 2 (ts):
```ts
import { v } from "convex/values";import { action } from "./_generated/server";export const similarFoods = action({  args: {    descriptionQuery: v.string(),  },  handler: async (ctx, args) => {    // 1. Generate an embedding from your favorite third party API:    const embedding = await embed(args.descriptionQuery);    // 2. Then search for similar foods!    const results = await ctx.vectorSearch("foods", "by_embedding", {      vector: embedding,      limit: 16,      filter: (q) => q.eq("cuisine", "French"),    });    // ...  },});
```

Example 3 (ts):
```ts
export const fetchResults = internalQuery({  args: { ids: v.array(v.id("foods")) },  handler: async (ctx, args) => {    const results = [];    for (const id of args.ids) {      const doc = await ctx.db.get(id);      if (doc === null) {        continue;      }      results.push(doc);    }    return results;  },});
```

Example 4 (ts):
```ts
export const similarFoods = action({  args: {    descriptionQuery: v.string(),  },  handler: async (ctx, args) => {    // 1. Generate an embedding from your favorite third party API:    const embedding = await embed(args.descriptionQuery);    // 2. Then search for similar foods!    const results = await ctx.vectorSearch("foods", "by_embedding", {      vector: embedding,      limit: 16,      filter: (q) => q.eq("cuisine", "French"),    });    // 3. Fetch the results    const foods: Array<Doc<"foods">> = await ctx.runQuery(      internal.foods.fetchResults,      { ids: results.map((result) => re
...
```

---

## Convex Overview

**URL:** https://docs.convex.dev/understanding/

**Contents:**
- Convex Overview
- Database​
- Server functions​
- Client libraries​
- Putting it all together​
- Beyond reactivity​
- For human and AI generated code​
- Learn more​

Convex is the open source, reactive database where queries are TypeScript code running right in the database. Just like React components react to state changes, Convex queries react to database changes.

Convex provides a database, a place to write your server functions, and client libraries. It makes it easy to build and scale dynamic live-updating apps.

The following diagram shows the standard three-tier app architecture that Convex enables. We'll start at the bottom and work our way up to the top of this diagram.

The database is at the core of Convex. The Convex database is automatically provisioned when you create your project. There is no connection setup or cluster management.

In Convex, your database queries are just TypeScript code written in your server functions. There is no SQL to write. There are no ORMs needed.

The Convex database is reactive. Whenever any data on which a query depends changes, the query is rerun, and client subscriptions are updated.

Convex is a "document-relational" database. "Document" means you put JSON-like nested objects into your database. "Relational" means you have tables with relations, like tasks assigned to a user using IDs to reference documents in other tables.

The Convex cloud offering runs on top of Amazon RDS using MySQL as its persistence layer. The Open Source version uses SQLite, Postgres and MySQL. The database is ACID-compliant and uses serializable isolation and optimistic concurrency control. All that to say, Convex provides the strictest possible transactional guarantees, and you never see inconsistent data.

When you create a new Convex project, you automatically get a convex/ folder where you write your server functions. This is where all your backend application logic and database query code live.

Example TypeScript server functions that read (query) and write (mutation) to the database.

You read and write to your database through query or mutation functions. Query functions are pure functions that can only read from the database. Mutation functions are transactions that can read or write from the database. These two database functions are not allowed to take any non-deterministic actions like network requests to ensure transactional guarantees.

The entire Convex mutation function is a transaction. There are no begin or end transaction statements to write. Convex automatically retries the function on conflicts, and you don't have to manage anything.

Convex also provides standard general-pu

*[Content truncated]*

**Examples:**

Example 1 (typescript):
```typescript
// A Convex query functionexport const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});// A Convex mutation functionexport const setTaskCompleted = mutation({  args: { taskId: v.id("tasks"), completed: v.boolean() },  handler: async (ctx, { taskId, completed }) => {    // Update the database using TypeScript    await ctx.db.patch(taskId, { completed });  
...
```

Example 2 (tsx):
```tsx
// In your React componentimport { useQuery } from "convex/react";import { api } from "../convex/_generated/api";export function TaskList() {  const data = useQuery(api.tasks.getAllOpenTasks);  return data ?? "Loading...";}
```

Example 3 (typescript):
```typescript
export const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});
```

Example 4 (json):
```json
[  { _id: "e4g", title: "Grocery shopping", complete: false },  { _id: "u9v", title: "Plant new flowers", complete: false },];
```

---

## Using Components

**URL:** https://docs.convex.dev/components/using-components

**Contents:**
- Using Components
- Installing Components​
- Component functions​
- Transactions​
- Dashboard​

Convex components add new features to your backend in their own sandbox with their own functions, schema and data, scheduled functions and all other fundamental Convex features.

You can see the full list of components in the directory. Each component README provides full instructions on how to install and use them.

This doc will go through common patterns on how to install and use Components.

We'll use the Sharded Counter component as an example.

Install the relevant package from npm

Create or update the convex.config.ts file in your app's convex/ folder and install the component by calling use:

Make sure the convex dev cli is running to ensure the component is registered with your backend and the necessary code is generated.

Each component has its own API. Check out each component's README file for more details on its usage.

Though components may expose higher level TypeScript APIs, under the hood they are called via normal Convex functions over the component sandbox boundary.

Queries, mutations, and action rules still apply - queries can only call component queries, mutations can also call component mutations, and actions can also call component actions. As a result, queries into components are reactive by default, and mutations have the same transaction guarantees.

Remember that mutation functions in Convex are transactions. Either all the changes in the mutation get written at once or none are written at all.

All writes for a top-level mutation call, including writes performed by calls into other components' mutations, are committed at the same time. If the top-level mutation throws an error, all of the writes are rolled back, and the mutation doesn't change the database at all.

However, if a component mutation call throws an exception, only its writes are rolled back. Then, if the caller catches the exception, it can continue, perform more writes, and return successfully. If the caller doesn't catch the exception, then it's treated as failed and all the writes associated with the caller mutation are rolled back. This means your code can choose a different code path depending on the semantics of your component.

As an example, take the Rate Limiter component. One API of the Rate Limiter throws an error if a rate limit is hit:

If the call to rateLimiter.limit throws an exception, we're over the rate limit. Then, if the calling mutation doesn't catch this exception, the whole transaction is rolled back.

The calling mutation, on the other ha

*[Content truncated]*

**Examples:**

Example 1 (bash):
```bash
npm i @convex-dev/sharded-counter
```

Example 2 (ts):
```ts
// convex/convex.config.tsimport { defineApp } from "convex/server";import shardedCounter from "@convex-dev/sharded-counter/convex.config";const app = defineApp();app.use(shardedCounter);//... Add other components hereexport default app;
```

Example 3 (bash):
```bash
npx convex dev
```

Example 4 (ts):
```ts
// Automatically throw an error if the rate limit is hit.await rateLimiter.limit(ctx, "failedLogins", { key: userId, throws: true });
```

---

## Local Deployments for Development

**URL:** https://docs.convex.dev/cli/local-deployments

**Contents:**
- Local Deployments for Development
- Background on deployments in Convex​
- Using local deployments​
  - Anonymous development​
  - Local deployments for an existing project​
- Local deployments vs. production​
  - Disabling​
- Limitations​

Instead of syncing code to a Convex dev deployment hosted in the cloud, you can develop against a deployment running on your own computer. You can even use the Convex dashboard with local deployments!

Each Convex deployment contains its own data, functions, scheduled functions, etc. A project has one production deployment, up to one cloud deployment for development per team member, and potentially many transient preview deployments.

You can also develop with Convex using a deployment running on your own machine. Since the deployment is running locally, code sync is faster and means resources like functions calls and database bandwidth don't count against the quotas for your Convex plan.

You can use local deployments with an existing Convex project, and view your deployment in the Convex dashboard under your project. You can also use local deployments without a Convex account and debug and inspect them with a locally running version of the Convex dashboard.

Local deployments are currently a beta feature. If you have feedback or feature requests, let us know on Discord!

While using local deployments, the local Convex backend runs as a subprocess of the npx convex dev command and exits when that command is stopped. This means a convex dev command must be running in order to run other commands like npx convex run against this local deployment or for your frontend to connect to this deployment.

State for local backends is stored the ~/.convex/ directory.

You can use local deployments to develop with Convex without having to create an account. Whenever you want to create an account to deploy your app to production or to use more Convex features, you can use npx convex login to link your local deployments with your account.

To use a local deployment for an existing project, run:

You'll also always be given the option for a local deployment if you run npx convex dev --configure. Other flows may assume you want a cloud deployment in some situations, for example when connecting to a project for which you already have a cloud development deployment.

Local deployments are not recommended for production use: they're development deployments, i.e. logs for function results and full stack traces for error responses are sent to connected clients.

For running a production application, you can use a production deployment hosted on the Convex cloud. Learn more about deploying to production here.

Alternatively, you can self-host a production deployment using the op

*[Content truncated]*

**Examples:**

Example 1 (sh):
```sh
npx convex dev --local --once
```

Example 2 (sh):
```sh
npx convex disable-local-deployments
```

---

## Errors and Warnings

**URL:** https://docs.convex.dev/error

**Contents:**
- Errors and Warnings
- Write conflict: Optimistic concurrency control​
  - Example A​
  - Example B​
  - Remediation​
  - Resources​

This page explains specific errors thrown by Convex.

See Error Handling to learn about handling errors in general.

This system error is thrown when a mutation repeatedly fails due to conflicting changes from parallel mutation executions.

A mutation updateCounter always updates the same document:

If this mutation is called many times per second, many of its executions will conflict with each other. Convex internally does several retries to mitigate this concern, but if the mutation is called more rapidly than Convex can execute it, some of the invocations will eventually throw this error:

Documents read from or written to the table "counters" changed while this mutation was being run and on every subsequent retry. Another call to this mutation changed the document with ID "123456789101112".

The error message will note the table name, which mutation caused the conflict (in this example its another call to the same mutation), and one document ID which was part of the conflicting change.

Mutation writeCount depends on the entire tasks table:

If the mutation writeCount is called at the same time as many calls to addTask are made, either of the mutations can fail with this error. This is because any change to the "tasks" table will conflict with the writeCount mutation:

Documents read from or written to the table "tasks" changed while this mutation was being run and on every subsequent retry. A call to "addTask" changed the document with ID "123456789101112".

**Examples:**

Example 1 (ts):
```ts
export const updateCounter = mutation({  args: {},  handler: async (ctx) => {    const doc = await ctx.db.get(process.env.COUNTER_ID);    await ctx.db.patch(doc._id, { value: doc.value + 1 });  },});
```

Example 2 (ts):
```ts
export const writeCount = mutation({  args: {    target: v.id("counts"),  },  handler: async (ctx, args) => {    const tasks = await ctx.db.query("tasks").collect();    await ctx.db.patch(args.target, { value: tasks });  },});export const addTask = mutation({  args: {    text: v.string(),  },  handler: async (ctx, args) => {    await ctx.db.insert("tasks", { text: args.text });  },});
```

---

## File Storage

**URL:** https://docs.convex.dev/file-storage

**Contents:**
- File Storage

File Storage makes it easy to implement file upload in your app, store files from and send files to third-party APIs, and to serve dynamic files to your users. All file types are supported.

You can manage your stored files on the dashboard.

Examples: File Storage with HTTP Actions, File Storage with Queries and Mutations

---

## CLI

**URL:** https://docs.convex.dev/using/cli

**Contents:**
- CLI
- Configure​
  - Create a new project​
  - Recreate project configuration​
  - Log out​
- Develop​
  - Run the Convex dev server​
  - Open the dashboard​
  - Open the docs​
  - Run Convex functions​

The Convex command-line interface (CLI) is your interface for managing Convex projects and Convex functions.

To install the CLI, run:

You can view the full list of commands with:

The first time you run

it will ask you to log in your device and create a new Convex project. It will then create:

in a project directory without a set CONVEX_DEPLOYMENT to configure a new or existing project.

Remove the existing Convex credentials from your device, so subsequent commands like npx convex dev can use a different Convex account.

Watches the local filesystem. When you change a function or the schema, the new versions are pushed to your dev deployment and the generated types in convex/_generated are updated. By default, logs from your dev deployment are displayed in the terminal.

It's also possible to run a Convex deployment locally for development.

Open the Convex dashboard.

Get back to these docs!

Run a public or internal Convex query, mutation, or action on your development deployment.

Arguments are specified as a JSON object.

Add --watch to live update the results of a query. Add --push to push local code to the deployment before running the function.

Use --prod to run functions in the production deployment for a project.

You can choose how to pipe logs from your dev deployment to your console:

Use --prod with npx convex logs to tail the prod deployment logs instead.

See description and use-cases: data import.

See description and use-cases: data export.

Display a simple view of the dashboard data page in the command line.

The command supports --limit and --order flags to change data displayed. For more complex filters, use the dashboard data page or write a query.

The npx convex data <table> command works with system tables, such as _storage, in addition to your own tables.

See and update the deployment environment variables which you can otherwise manage on the dashboard environment variables settings page.

The target deployment to push to is determined like this:

Once this command succeeds the new functions will be available immediately.

When run with the CONVEX_DEPLOY_KEY environment variable containing a Preview Deploy Key, this command will:

Create a new Convex deployment. npx convex deploy will infer the Git branch name for Vercel, Netlify, GitHub, and GitLab environments, or the --preview-create option can be used to customize the name associated with the newly created deployment.

Run a command if specified with --cmd. The command

*[Content truncated]*

**Examples:**

Example 1 (sh):
```sh
npm install convex
```

Example 2 (sh):
```sh
npx convex dev
```

Example 3 (sh):
```sh
npx convex dev
```

Example 4 (sh):
```sh
npx convex logout
```

---

## Continuous Integration

**URL:** https://docs.convex.dev/testing/ci

**Contents:**
- Continuous Integration
- Testing in GitHub Actions​

Continuous integration allows your team to move fast by combining changes from all team members and automatically testing them on a remote machine.

It's easy if you're using GitHub to set up CI workflow for running your test suite:

After you commit and push this file to your repository, GitHub will run npm run test every time you create a pull request or push a new commit.

**Examples:**

Example 1 (yaml):
```yaml
name: Run Testson: [pull_request, push]jobs:  build:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v4      - uses: actions/setup-node@v4      - run: npm ci      - run: npm run test
```

---

## Cron Jobs

**URL:** https://docs.convex.dev/scheduling/cron-jobs

**Contents:**
- Cron Jobs
- Defining your cron jobs​
- Supported schedules​
- Viewing your cron jobs​
- Error handling​

Convex allows you to schedule functions to run on a recurring basis. For example, cron jobs can be used to clean up data at a regular interval, send a reminder email at the same time every month, or schedule a backup every Saturday.

Cron jobs are defined in a crons.ts file in your convex/ directory and look like:

The first argument is a unique identifier for the cron job.

The second argument is the schedule at which the function should run, see Supported schedules below.

The third argument is the name of the public function or internal function, either a mutation or an action.

You can view all your cron jobs in the Convex dashboard cron jobs view. You can view added, updated, and deleted cron jobs in the logs and history view. Results of previously executed runs of the cron jobs are also available in the logs view.

Mutations and actions have the same guarantees that are described in Error handling for scheduled functions.

At most one run of each cron job can be executing at any moment. If the function scheduled by the cron job takes too long to run, following runs of the cron job may be skipped to avoid execution from falling behind. Skipping a scheduled run of a cron job due to the previous run still executing logs a message visible in the logs view of the dashboard.

**Examples:**

Example 1 (ts):
```ts
import { cronJobs } from "convex/server";import { internal } from "./_generated/api";const crons = cronJobs();crons.interval(  "clear messages table",  { minutes: 1 }, // every minute  internal.messages.clearAll,);crons.monthly(  "payment reminder",  { day: 1, hourUTC: 16, minuteUTC: 0 }, // Every month on the first day at 8:00am PST  internal.payments.sendPaymentEmail,  { email: "my_email@gmail.com" }, // argument to sendPaymentEmail);// An alternative way to create the same schedule as above with cron syntaxcrons.cron(  "payment reminder duplicate",  "0 16 1 * *",  internal.payments.sendPaym
...
```

---

## 

**URL:** https://docs.convex.dev

---

## Custom JWT Provider

**URL:** https://docs.convex.dev/auth/advanced/custom-jwt

**Contents:**
- Custom JWT Provider
- Server-side integration​
  - Warning: omitting applicationID is often insecure​
  - Custom claims​
- Client-side integration​

Note: This is an advanced feature! We recommend sticking with the supported third-party authentication providers.

A JWT is a string combining three base64-encoded JSON objects containing claims about who a user is valid for a limited period of time like an hour. You can create them with a library like jose after receiving some evidence (typically a cookie) of a user's identity or get them from a third party authentication service like Clerk. The information in a JWT is signed (the Convex deployment can tell the information is really from the issuer and hasn't been modified) but generally not encrypted (you can read it by base64-decoding the token or pasting it into jwt.io.

If the JWTs issued to your users by an authentication service contain the right fields to implement the OpenID Connect (OIDC) protocol, the easiest way to configure accepting these JWTs is adding an OIDC Provider entry in convex/auth.config.ts. If the authentication service or library you're using to issue JWTs doesn't support these fields (for example OpenAuth JWTs missing an aud field because they implement the OAuth 2.0 spec but not OIDC) you'll need to configure a Custom JWT provider in the convex/auth.config.ts file.

Custom JWTs are required only to have header fields kid, alg and typ, and payload fields sub, iss, and exp. An iat field is also expected by Convex clients to implement token refreshing.

Use type: "customJwt" to configure a Custom JWT auth provider:

The issuer property must exactly match the iss field of the JWT used and if specified the applicationID property must exactly match the aud field. If your JWT doesn't match, use a tool like jwt.io to view an JWT and confirm these fields match exactly.

Leaving out applicationID from an auth configuration means the aud (audience) field of your users' JWTs will not be verified. In many cases this is insecure because a JWT intended for another service can be used to impersonate them in your service.

Say a user has accounts with https://todos.com and https://banking.com, two services which use the same third-party authentication service, accounts.google.com. A JWT accepted by todos.com could be reused to authenticate with banking.com by either todos.com or an attacker that obtained access to that JWT.

The aud (audience) field of the JWT prevents this: if the JWT was generated for a specific audience of https://todos.com then banking.com can enforce the aud field and know not to accept it.

If the JWTs issued to your users

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { AuthConfig } from "convex/server";export default {  providers: [    {      type: "customJwt",      applicationID: "your-application-id",      issuer: "https://your.issuer.url.com",      jwks: "https://your.issuer.url.com/.well-known/jwks.json",      algorithm: "RS256",    },  ],};
```

Example 2 (json):
```json
{  "properties": {    "id": "123",    "favoriteColor": "red"  },  "iss": "http://localhost:3000",  "sub": "user:8fa2be73c2229e85",  "exp": 1750968478}
```

---

## Serving Files

**URL:** https://docs.convex.dev/file-storage/serve-files

**Contents:**
- Serving Files
- Generating file URLs in queries​
- Serving files from HTTP actions​

Files stored in Convex can be served to your users by generating a URL pointing to a given file.

The simplest way to serve files is to return URLs along with other data required by your app from queries and mutations.

A file URL can be generated from a storage ID by the storage.getUrl function of the QueryCtx, MutationCtx, or ActionCtx object:

File URLs can be used in img elements to render images:

In your query you can control who gets access to a file when the URL is generated. If you need to control access when the file is served, you can define your own file serving HTTP actions instead.

You can serve files directly from HTTP actions. An HTTP action will need to take some parameter(s) that can be mapped to a storage ID, or a storage ID itself.

This enables access control at the time the file is served, such as when an image is displayed on a website. But note that the HTTP actions response size is currently limited to 20MB. For larger files you need to use file URLs as described above.

A file Blob object can be generated from a storage ID by the storage.get function of the ActionCtx object, which can be returned in a Response:

The URL of such an action can be used directly in img elements to render images:

**Examples:**

Example 1 (ts):
```ts
import { query } from "./_generated/server";export const list = query({  args: {},  handler: async (ctx) => {    const messages = await ctx.db.query("messages").collect();    return Promise.all(      messages.map(async (message) => ({        ...message,        // If the message is an "image" its `body` is an `Id<"_storage">`        ...(message.format === "image"          ? { url: await ctx.storage.getUrl(message.body) }          : {}),      })),    );  },});
```

Example 2 (tsx):
```tsx
function Image({ message }: { message: { url: string } }) {  return <img src={message.url} height="300px" width="auto" />;}
```

Example 3 (ts):
```ts
import { httpRouter } from "convex/server";import { httpAction } from "./_generated/server";import { Id } from "./_generated/dataModel";const http = httpRouter();http.route({  path: "/getImage",  method: "GET",  handler: httpAction(async (ctx, request) => {    const { searchParams } = new URL(request.url);    const storageId = searchParams.get("storageId")! as Id<"_storage">;    const blob = await ctx.storage.get(storageId);    if (blob === null) {      return new Response("Image not found", {        status: 404,      });    }    return new Response(blob);  }),});export default http;
```

Example 4 (tsx):
```tsx
const convexSiteUrl = import.meta.env.VITE_CONVEX_SITE_URL;function Image({ storageId }: { storageId: string }) {  // e.g. https://happy-animal-123.convex.site/getImage?storageId=456  const getImageUrl = new URL(`${convexSiteUrl}/getImage`);  getImageUrl.searchParams.set("storageId", storageId);  return <img src={getImageUrl.href} height="300px" width="auto" />;}
```

---

## Authentication

**URL:** https://docs.convex.dev/auth

**Contents:**
- Authentication
- Third-party authentication platforms​
- The Convex Auth Library​
- Debugging​
- Service Authentication​
- Authorization​

Convex deployment endpoints are exposed to the open internet and the claims clients make about who they are must be authenticated to identify users and restrict what data they can see and edit.

Convex is compatible with most authentication providers because it uses OpenID Connect (based on OAuth) ID tokens in the form of JWTs to authenticate WebSocket connections or RPCs. These JWTs can be provided by any service (including your own Convex backend) that implement the appropriate OAuth endpoints to verify them.

Leveraging a Convex integration with a third-party auth provider provides the most comprehensive authentication solutions. Integrating another service provides a ton of functionality like passkeys, two-factor auth, spam protection, and more on top of the authentication basics.

After you integrate one of these, learn more about accessing authentication information in Functions and storing user information in the Database.

For client-side React and React Native mobile apps you can implement auth directly in Convex with the Convex Auth library. This npm package runs on your Convex deployment and helps you build a custom sign-up/sign-in flow via social identity providers, one-time email or SMS access codes, or via passwords.

Convex Auth is in beta (it isn't complete and may change in backward-incompatible ways) and doesn't provide as many features as third party auth integrations. Since it doesn't require signing up for another service it's the quickest way to get auth up and running.

Convex Auth is currently a beta feature. If you have feedback or feature requests, let us know on Discord!

Support for Next.js is under active development. If you'd like to help test this experimental support please give it a try!

If you run into issues consult the Debugging guide.

Servers you control or third party services can call Convex functions but may not be able to obtain OpenID JWTs and often do not represent the actions of a specific user.

Say you're running some inference on a Modal server written in Python. When that server subscribes to a Convex query it doesn't do so with credentials of a particular end-user, rather it's looking for relevant tasks for any users that need that inference task, say summarizing and translating a conversation, completed.

To provide access to Convex queries, mutations, and actions to an external service you can write public functions accessible to the internet that check a shared secret, for example from an environment va

*[Content truncated]*

**Examples:**

Example 1 (typescript):
```typescript
export const removeUserImage = mutation({  args: {},  handler: async (ctx) => {    const userId = await getAuthUserId(ctx);    if (!userId) {      return;    }    ctx.db.patch(userId, { imageId: undefined, image: undefined });  },});
```

---

## Best Practices

**URL:** https://docs.convex.dev/understanding/best-practices/

**Contents:**
- Best Practices
- Await all Promises​
  - Why?​
  - How?​
- Avoid .filter on database queries​
  - Why?​
  - Examples​
  - How?​
  - Exceptions​
- Only use .collect with a small number of results​

This is a list of best practices and common anti-patterns around using Convex. We recommend going through this list before broadly releasing your app to production. You may choose to try using all of these best practices from the start, or you may wait until you've gotten major parts of your app working before going through and adopting the best practices here.

Convex functions use async / await. If you don't await all your promises (e.g. await ctx.scheduler.runAfter, await ctx.db.patch), you may run into unexpected behavior (e.g. failing to schedule a function) or miss handling errors.

We recommend the no-floating-promises eslint rule with TypeScript.

Filtering in code instead of using the .filter syntax has the same performance, and is generally easier code to write. Conditions in .withIndex or .withSearchIndex are more efficient than .filter or filtering in code, so almost all uses of .filter should either be replaced with a .withIndex or .withSearchIndex condition, or written as TypeScript code.

Read through the indexes documentation for an overview of how to define indexes and how they work.

Search for .filter in your Convex codebase — a regex like \.filter\(\(?q will probably find all the ones on database queries.

Decide whether they should be replaced with a .withIndex condition — per this section, if you are filtering over a large (1000+) or potentially unbounded number of documents, you should use an index. If not using a .withIndex / .withSearchIndex condition, consider replacing them with a filter in code for more readability and flexibility.

See this article for more strategies for filtering.

Using .filter on a paginated query (.paginate) has advantages over filtering in code. The paginated query will return the number of documents requested, including the .filter condition, so filtering in code afterwards can result in a smaller page or even an empty page. Using .withIndex on a paginated query will still be more efficient than a .filter.

All results returned from .collect count towards database bandwidth (even ones filtered out by .filter). It also means that if any document in the result changes, the query will re-run or the mutation will hit a conflict.

If there's a chance the number of results is large (say 1000+ documents), you should use an index to filter the results further before calling .collect, or find some other way to avoid loading all the documents such as using pagination, denormalizing data, or changing the product fe

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
// ❌const tomsMessages = ctx.db  .query("messages")  .filter((q) => q.eq(q.field("author"), "Tom"))  .collect();// ✅// Option 1: Use an indexconst tomsMessages = await ctx.db  .query("messages")  .withIndex("by_author", (q) => q.eq("author", "Tom"))  .collect();// Option 2: Filter in codeconst allMessages = await ctx.db.query("messages").collect();const tomsMessages = allMessages.filter((m) => m.author === "Tom");
```

Example 2 (ts):
```ts
// ❌ -- potentially unboundedconst allMovies = await ctx.db.query("movies").collect();const moviesByDirector = allMovies.filter(  (m) => m.director === "Steven Spielberg",);// ✅ -- small number of results, so `collect` is fineconst moviesByDirector = await ctx.db  .query("movies")  .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))  .collect();
```

Example 3 (ts):
```ts
// ❌ -- potentially unboundedconst watchedMovies = await ctx.db  .query("watchedMovies")  .withIndex("by_user", (q) => q.eq("user", "Tom"))  .collect();// ✅ -- using pagination, showing recently watched movies firstconst watchedMovies = await ctx.db  .query("watchedMovies")  .withIndex("by_user", (q) => q.eq("user", "Tom"))  .order("desc")  .paginate(paginationOptions);
```

Example 4 (ts):
```ts
// ❌ -- potentially unboundedconst watchedMovies = await ctx.db  .query("watchedMovies")  .withIndex("by_user", (q) => q.eq("user", "Tom"))  .collect();const numberOfWatchedMovies = watchedMovies.length;// ✅ -- Show "99+" instead of needing to load all documentsconst watchedMovies = await ctx.db  .query("watchedMovies")  .withIndex("by_user", (q) => q.eq("user", "Tom"))  .take(100);const numberOfWatchedMovies =  watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();// ✅ -- Denormalize the number of watched movies in a separate tableconst watchedMoviesCount = await ctx.db  .que
...
```

---

## convex-test

**URL:** https://docs.convex.dev/testing/convex-test

**Contents:**
- convex-test
- Get Started​
- convexTest​
- Calling functions with t.query, t.mutation and t.action​
- Setting up and inspecting data and storage with t.run​
- Testing HTTP actions with t.fetch​
- Testing scheduled functions​
- Testing authentication with t.withIdentity​
- Mocking fetch calls​
- Asserting results​

The convex-test library provides a mock implementation of the Convex backend in JavaScript. It enables fast automated testing of the logic in your functions.

Example: The library includes a test suite which you can browse to see examples of using it.

Install Vitest and the convex-test library.

Add these scripts to your package.json

Add vitest.config.mts file to configure the test environment to better match the Convex runtime, and to inline the test library for better dependency tracking.

In your convex folder add a file ending in .test.ts

The example test calls the api.messages.send mutation twice and then asserts that the api.messages.list query returns the expected results.

Start the tests with npm run test. When you change the test file or your functions the tests will rerun automatically.

If you're not familiar with Vitest or Jest read the Vitest Getting Started docs first.

The library exports a convexTest function which should be called at the start of each of your tests. The function returns an object which is by convention stored in the t variable and which provides methods for exercising your Convex functions.

If your project uses a schema you should pass it to the convexTest function:

Passing in the schema is required for the tests to correctly implement schema validation and for correct typing of t.run.

If you don't have a schema, call convexTest() with no argument.

Your test can call public and internal Convex functions in your project:

Sometimes you might want to directly write to the mock database or file storage from your test, without needing a declared function in your project. You can use the t.run method which takes a handler that is given a ctx that allows reading from and writing to the mock backend:

Your test can call HTTP actions registered by your router:

Mocking the global fetch function doesn't affect t.fetch, but you can use t.fetch in a fetch mock to route to your HTTP actions.

One advantage of using a mock implementation running purely in JavaScript is that you can control time in the Vitest test environment. To test implementations relying on scheduled functions use Vitest's fake timers in combination with t.finishInProgressScheduledFunctions:

If you have a chain of several scheduled functions, for example a mutation that schedules an action that schedules another action, you can use t.finishAllScheduledFunctions to wait for all scheduled functions, including recursively scheduled functions, to finish:

Check

*[Content truncated]*

**Examples:**

Example 1 (sh):
```sh
npm install --save-dev convex-test vitest @edge-runtime/vm
```

Example 2 (json):
```json
"scripts": {  "test": "vitest",  "test:once": "vitest run",  "test:debug": "vitest --inspect-brk --no-file-parallelism",  "test:coverage": "vitest run --coverage --coverage.reporter=text",}
```

Example 3 (ts):
```ts
import { defineConfig } from "vitest/config";export default defineConfig({  test: {    environment: "edge-runtime",    server: { deps: { inline: ["convex-test"] } },  },});
```

Example 4 (ts):
```ts
import { convexTest } from "convex-test";import { expect, test } from "vitest";import { api } from "./_generated/api";import schema from "./schema";test("sending messages", async () => {  const t = convexTest(schema);  await t.mutation(api.messages.send, { body: "Hi!", author: "Sarah" });  await t.mutation(api.messages.send, { body: "Hey!", author: "Tom" });  const messages = await t.query(api.messages.list);  expect(messages).toMatchObject([    { body: "Hi!", author: "Sarah" },    { body: "Hey!", author: "Tom" }  ]);});
```

---

## Deployments

**URL:** https://docs.convex.dev/dashboard/deployments/

**Contents:**
- Deployments

Each project in Convex has a main production deployment, and each developer on your team can also set up their own personal development deployment. Additionally, there are preview deployments used to test backend changes before they're deployed to production.

While on a deployment page, you may switch between production, your development deployment, and any preview deployments by using the dropdown menu on the top-left of the page.

---

## Convex Auth

**URL:** https://docs.convex.dev/auth/convex-auth

**Contents:**
- Convex Auth
- Get Started​
- Overview​

Convex Auth is a library for implementing authentication directly within your Convex backend. This allows you to authenticate users without needing an authentication service or even a hosting server. Convex Auth currently supports client-side React web apps served from a CDN and React Native mobile apps.

Example: Live Demo (Source)

Convex Auth is currently a beta feature. If you have feedback or feature requests, let us know on Discord!

Support for authentication in Next.js server components, API routes, middleware, SSR etc. is under active development. If you'd like to help test this experimental support please let us know how it goes in Discord.

To start a new project from scratch with Convex and Convex Auth, run:

and choose React (Vite) and Convex Auth.

To add Convex Auth to an existing project, follow the full setup guide.

Convex Auth enables you to implement the following authentication methods:

The library doesn't come with UI components, but you can copy code from the docs and example repo to quickly build a UI in React.

Learn more in the Convex Auth docs.

**Examples:**

Example 1 (sh):
```sh
npm create convex@latest
```

---

## Vector Search

**URL:** https://docs.convex.dev/vector-search

**Contents:**
- Vector Search
- Defining vector indexes​
- Running vector searches​
  - Filter expressions​
  - Other filtering​
  - Ordering​
- Advanced patterns​
  - Using a separate table to store vectors​
  - Fetching results and adding new documents​
- Limits​

Vector search allows you to find Convex documents similar to a provided vector. Typically, vectors will be embeddings which are numerical representations of text, images, or audio.

Embeddings and vector search enable you to provide useful context to LLMs for AI powered applications, recommendations for similar content and more.

Vector search is consistent and fully up-to-date. You can write a vector and immediately read it from a vector search. Unlike full text search, however, vector search is only available in Convex actions.

Example: Vector Search App

To use vector search you need to:

Like database indexes, vector indexes are a data structure that is built in advance to enable efficient querying. Vector indexes are defined as part of your Convex schema.

To add a vector index onto a table, use the vectorIndex method on your table's schema. Every vector index has a unique name and a definition with:

For example, if you want an index that can search for similar foods within a given cuisine, your table definition could look like:

You can specify vector and filter fields on nested documents by using a dot-separated path like properties.name.

Unlike database queries or full text search, vector searches can only be performed in a Convex action.

They generally involve three steps:

Here's an example of the first two steps for searching for similar French foods based on a description:

An example of the first step can be found here in the vector search demo app.

Focusing on the second step, the vectorSearch API takes in the table name, the index name, and finally a VectorSearchQuery object describing the search. This object has the following fields:

It returns an Array of objects containing exactly two fields:

Neither the underlying document nor the vector are included in results, so once you have the list of results, you will want to load the desired information about the results.

There are a few strategies for loading this information documented in the Advanced Patterns section.

For now, let's load the documents and return them from the action. To do so, we'll pass the list of results to a Convex query and run it inside of our action, returning the result:

As mentioned above, vector searches support efficiently filtering results by additional fields on your document using either exact equality on a single field, or an OR of expressions.

For example, here's a filter for foods with cuisine exactly equal to "French":

You can also filter document

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
foods: defineTable({  description: v.string(),  cuisine: v.string(),  embedding: v.array(v.float64()),}).vectorIndex("by_embedding", {  vectorField: "embedding",  dimensions: 1536,  filterFields: ["cuisine"],}),
```

Example 2 (ts):
```ts
import { v } from "convex/values";import { action } from "./_generated/server";export const similarFoods = action({  args: {    descriptionQuery: v.string(),  },  handler: async (ctx, args) => {    // 1. Generate an embedding from your favorite third party API:    const embedding = await embed(args.descriptionQuery);    // 2. Then search for similar foods!    const results = await ctx.vectorSearch("foods", "by_embedding", {      vector: embedding,      limit: 16,      filter: (q) => q.eq("cuisine", "French"),    });    // ...  },});
```

Example 3 (ts):
```ts
export const fetchResults = internalQuery({  args: { ids: v.array(v.id("foods")) },  handler: async (ctx, args) => {    const results = [];    for (const id of args.ids) {      const doc = await ctx.db.get(id);      if (doc === null) {        continue;      }      results.push(doc);    }    return results;  },});
```

Example 4 (ts):
```ts
export const similarFoods = action({  args: {    descriptionQuery: v.string(),  },  handler: async (ctx, args) => {    // 1. Generate an embedding from your favorite third party API:    const embedding = await embed(args.descriptionQuery);    // 2. Then search for similar foods!    const results = await ctx.vectorSearch("foods", "by_embedding", {      vector: embedding,      limit: 16,      filter: (q) => q.eq("cuisine", "French"),    });    // 3. Fetch the results    const foods: Array<Doc<"foods">> = await ctx.runQuery(      internal.foods.fetchResults,      { ids: results.map((result) => re
...
```

---
